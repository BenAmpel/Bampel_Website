{{/* Interactive Research Network - Usage: {{< research_network >}} */}}

<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

{{ $seed := "abcdefghijklmnopqrstuvwxyz" }}
{{ $uniqueID := delimit (shuffle (split $seed "")) "" }}
<div id="network-{{ $uniqueID }}" style="width: 100%; min-height: 700px; height: 700px; border: 1px solid #eee; border-radius: 8px; overflow: hidden; position: relative;"></div>

<script type="text/javascript">
(function() {
    var domID = "network-{{ $uniqueID }}";
    var myName = "Benjamin Ampel"; // The center node

    // --- 1. NAME NORMALIZATION ---
    var nameMap = {
        'B Ampel': 'Benjamin Ampel', 'BM Ampel': 'Benjamin Ampel', 'B. Ampel': 'Benjamin Ampel', 'admin': 'Benjamin Ampel',
        'H Chen': 'Hsinchun Chen', 'H. Chen': 'Hsinchun Chen',
        'S Samtani': 'Sagar Samtani', 'S. Samtani': 'Sagar Samtani',
        'S Ullman': 'Steven Ullman', 'S. Ullman': 'Steven Ullman',
        'H Zhu': 'Hongyi Zhu', 'H. Zhu': 'Hongyi Zhu',
        'M Patton': 'Mark Patton', 'M. Patton': 'Mark Patton',
        'B Lazarine': 'Ben Lazarine', 'B. Lazarine': 'Ben Lazarine',
        'T Vahedi': 'Tala Vahedi', 'T. Vahedi': 'Tala Vahedi',
        'K Otto': 'Kaeli Otto', 'K. Otto': 'Kaeli Otto',
        'Y Gao': 'Yang Gao', 'Y. Gao': 'Yang Gao',
        'J Hu': 'James Hu', 'J. Hu': 'James Hu',
        'CH Yang': 'Chi-Heng Yang', 'JF Nunamaker Jr': 'Jay Nunamaker',
        'C Marx': 'Carolin Marx', 'C Dacosta': 'Cade Dacosta',
        'C Zhang': 'Chengjun Zhang', 'M Hashim': 'Matthew Hashim',
        'M Wagner': 'Mason Wagner', 'RY Reyes': 'Raul Reyes',
        'S Yang': 'Shanchieh Yang', 'Y Li': 'Yidong Li', 'Y. Li': 'Yidong Li'
    };
    function normalize(name) { return nameMap[name] || name; }

    // --- 2. COLOR GENERATOR ---
    function getColor(value, max, isDark) {
        var safeMax = (max <= 1) ? 2 : max;
        var ratio = Math.min(Math.max((value - 1) / (safeMax - 1), 0), 1);
        if (isDark) {
            var hue = (1 - ratio) * 120; 
            return `hsl(${hue}, 90%, 60%)`;
        } else {
            var hue = (1 - ratio) * 120;
            return `hsl(${hue}, 80%, 40%)`;
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        var dom = document.getElementById(domID);
        if (!dom) return;

        var myChart = echarts.init(dom);
        myChart.showLoading();

        var globalData = { nodes: [], links: [], maxCount: 0 };

        // --- 3. FETCH & PROCESS DATA ---
        fetch('/data/publications.json')
            .then(response => response.json())
            .then(data => {
                myChart.hideLoading();
                // [FIX 1] Handle Object wrapper vs Direct List
                let papers = Array.isArray(data) ? data : (data.individualPublications || []);
                processData(papers);
            })
            .catch(err => {
                console.error("Network Error:", err);
                myChart.hideLoading();
                dom.innerHTML = "<p style='text-align:center; padding-top:20px; opacity:0.6;'>Network data unavailable.</p>";
            });

        function processData(papers) {
            var nodeCounts = new Map();
            var linkCounts = new Map(); 
            var maxCount = 0;

            // Step A: Aggregate Counts
            if (!papers || papers.length === 0) return;

            papers.forEach(function(paper) {
                var rawAuthors = paper.authors;
                if (!rawAuthors) return;

                // [FIX 2] Handle String ("A, B") vs Array (["A", "B"])
                var authorList = Array.isArray(rawAuthors) ? rawAuthors : rawAuthors.split(',');
                
                // Clean and Normalize
                var authors = [...new Set(authorList.map(a => normalize(a.trim())).filter(a => a))]; 
                
                // Count Nodes
                authors.forEach(auth => {
                    let count = (nodeCounts.get(auth) || 0) + 1;
                    nodeCounts.set(auth, count);
                    if (auth !== myName && count > maxCount) maxCount = count;
                });

                // Count Links
                for (let i = 0; i < authors.length; i++) {
                    for (let j = i + 1; j < authors.length; j++) {
                        let source = authors[i], target = authors[j];
                        if (source === target) continue;
                        let pairId = [source, target].sort().join("|");
                        linkCounts.set(pairId, (linkCounts.get(pairId) || 0) + 1);
                    }
                }
            });

            // Step B: Build Nodes
            globalData.maxCount = maxCount;
            globalData.rawNodes = Array.from(nodeCounts.entries());

            // Step C: Build Weighted Links
            globalData.links = Array.from(linkCounts.entries()).map(([id, count]) => {
                let [source, target] = id.split("|");
                return {
                    source: source,
                    target: target,
                    value: count,
                    lineStyle: {
                        width: Math.min(1.5 + (count * 0.8), 6),
                        opacity: Math.min(0.3 + (count * 0.1), 0.9)
                    }
                };
            });
            
            updateChart();
        }

        // --- 4. RENDER CHART ---
        function updateChart() {
            var isDark = document.body.classList.contains('dark');
            var bgColor = isDark ? 'transparent' : 'transparent'; // Transparent to blend with card
            var textColor = isDark ? '#eeeeee' : '#333333';
            var textBorder = isDark ? '#000000' : '#ffffff'; 
            var meColor = isDark ? '#ffffff' : '#000000';

            var nodes = globalData.rawNodes.map(([name, count]) => {
                let isMe = (name === myName);
                return {
                    id: name,
                    name: name,
                    value: count,
                    symbolSize: isMe ? 75 : Math.max(25, Math.min(65, count * 10)),
                    itemStyle: {
                        color: isMe ? meColor : getColor(count, globalData.maxCount, isDark),
                        borderColor: isDark ? '#000' : '#fff',
                        borderWidth: 1.5
                    },
                    label: {
                        show: count > 1 || isMe,
                        color: textColor,
                        textBorderColor: textBorder,
                        textBorderWidth: 3, 
                        fontSize: isMe ? 14 : 11,
                        fontWeight: 'bold'
                    },
                    // Pin "Me" to center
                    fixed: isMe,
                    x: isMe ? dom.clientWidth / 2 : null,
                    y: isMe ? dom.clientHeight / 2 : null,
                    z: isMe ? 10 : 1
                };
            });

            var links = globalData.links.map(link => ({
                source: link.source,
                target: link.target,
                value: link.value,
                lineStyle: {
                    color: getColor(link.value, globalData.maxCount, isDark),
                    width: Math.min(1.5 + (link.value * 0.8), 6),
                    opacity: 0.8 
                }
            }));

            var option = {
                backgroundColor: bgColor,
                animationDuration: 1500,
                animationEasingUpdate: 'quinticInOut',
                tooltip: { 
                    formatter: (params) => {
                        if (params.dataType === 'edge') return `${params.data.source} & ${params.data.target}<br><strong>${params.value} Papers</strong>`;
                        return `${params.marker} <strong>${params.name}</strong><br>Papers: ${params.value}`;
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'force',
                    data: nodes,
                    links: links,
                    roam: true,
                    zoom: 0.75,
                    label: { position: 'right' },
                    lineStyle: { curveness: 0.2 },
                    force: {
                        initLayout: 'circular',
                        repulsion: 2000,
                        gravity: 0.1,
                        edgeLength: [50, 200],
                        friction: 0.9
                    }
                }]
            };

            myChart.setOption(option);
            
            // Force re-center of Main Node
            var w = myChart.getWidth(), h = myChart.getHeight();
            nodes.forEach(n => { if(n.id === myName) { n.x = w/2; n.y = h/2; } });
            myChart.setOption({ series: [{ data: nodes }] });
        }

        // --- 5. EVENTS ---
        new ResizeObserver(() => myChart.resize()).observe(dom);
        
        const themeButton = document.querySelector('.js-theme-toggle');
        if(themeButton){
            themeButton.addEventListener('click', () => setTimeout(updateChart, 100));
        }
    });
})();
</script>
