{{/* Interactive Research Network - Usage: {{< research_network >}} */}}
{{/* Fetches publications.json and builds co-authorship network client-side */}}

<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

{{ $seed := "abcdefghijklmnopqrstuvwxyz" }}
{{ $uniqueID := delimit (shuffle (split $seed "")) "" }}
<div id="network-{{ $uniqueID }}" style="width: 100%; min-height: 600px; height: 600px; border: 1px solid #eee; border-radius: 8px; overflow: hidden; position: relative;"></div>

<script type="text/javascript">
(function() {
    var domID = "network-{{ $uniqueID }}";
    var myName = "Benjamin Ampel"; // The center node

    // Name Normalization (Ported from your Python script)
    var nameMap = {
        'B Ampel': 'Benjamin Ampel', 'BM Ampel': 'Benjamin Ampel', 'B. Ampel': 'Benjamin Ampel', 'admin': 'Benjamin Ampel',
        'H Chen': 'Hsinchun Chen', 'H. Chen': 'Hsinchun Chen',
        'S Samtani': 'Sagar Samtani', 'S. Samtani': 'Sagar Samtani',
        'S Ullman': 'Steven Ullman', 'S. Ullman': 'Steven Ullman',
        'H Zhu': 'Hongyi Zhu', 'H. Zhu': 'Hongyi Zhu',
        'M Patton': 'Mark Patton', 'M. Patton': 'Mark Patton',
        'B Lazarine': 'Ben Lazarine', 'B. Lazarine': 'Ben Lazarine',
        'T Vahedi': 'Tala Vahedi', 'T. Vahedi': 'Tala Vahedi',
        'K Otto': 'Kaeli Otto', 'K. Otto': 'Kaeli Otto',
        'Y Gao': 'Yang Gao', 'Y. Gao': 'Yang Gao',
        'J Hu': 'James Hu', 'J. Hu': 'James Hu',
        'CH Yang': 'Chi-Heng Yang', 'JF Nunamaker Jr': 'Jay Nunamaker',
        'C Marx': 'Carolin Marx', 'C Dacosta': 'Cade Dacosta',
        'C Zhang': 'Chengjun Zhang', 'M Hashim': 'Matthew Hashim',
        'M Wagner': 'Mason Wagner', 'RY Reyes': 'Raul Reyes',
        'S Yang': 'Shanchieh Yang'
    };

    function normalize(name) {
        return nameMap[name] || name;
    }

    document.addEventListener('DOMContentLoaded', function() {
        var dom = document.getElementById(domID);
        if (!dom) return;

        var myChart = echarts.init(dom);
        myChart.showLoading(); // Show loading spinner while fetching JSON

        // 1. FETCH DATA DIRECTLY (Bypasses Hugo Templating)
        fetch('/data/publications.json')
            .then(response => response.json())
            .then(data => {
                myChart.hideLoading();
                processData(data);
            })
            .catch(err => {
                console.error("Failed to load publications:", err);
                myChart.hideLoading();
                dom.innerHTML = "<p style='text-align:center; padding-top:20px; color:red;'>Could not load network data.</p>";
            });

        function processData(papers) {
            var nodeCounts = new Map();
            var links = [];
            var connectedPairs = new Set();

            // A. Process Authors
            papers.forEach(function(paper) {
                if (!paper.authors) return;
                
                // Get normalized list of authors for this paper
                var authors = paper.authors.map(normalize);
                
                // Add nodes
                authors.forEach(auth => {
                    nodeCounts.set(auth, (nodeCounts.get(auth) || 0) + 1);
                });

                // Add links (All-to-All within the paper)
                for (let i = 0; i < authors.length; i++) {
                    for (let j = i + 1; j < authors.length; j++) {
                        let source = authors[i];
                        let target = authors[j];
                        
                        // Avoid self-loops
                        if (source === target) continue;

                        // Ensure unique link ID (A-B is same as B-A)
                        let pairId = [source, target].sort().join("-");
                        if (!connectedPairs.has(pairId)) {
                            links.push({ source: source, target: target });
                            connectedPairs.add(pairId);
                        }
                    }
                }
            });

            // B. Format for ECharts
            var nodes = Array.from(nodeCounts.entries()).map(([name, count]) => {
                let isMe = (name === myName);
                return {
                    id: name,
                    name: name,
                    symbolSize: isMe ? 60 : Math.max(15, count * 8), // Size by frequency
                    itemStyle: { color: isMe ? '#d93025' : '#1a0dab' }, // Red for you, Blue for others
                    category: isMe ? 0 : 1,
                    fixed: isMe,
                    x: isMe ? dom.clientWidth / 2 : null,
                    y: isMe ? dom.clientHeight / 2 : null,
                    value: count,
                    label: { show: count > 1 || isMe } // Only show labels for frequent collaborators
                };
            });

            renderChart(nodes, links);
        }

        function renderChart(nodes, links) {
            var option = {
                tooltip: { formatter: '{b}: {c} Papers' },
                series: [{
                    type: 'graph',
                    layout: 'force',
                    data: nodes,
                    links: links,
                    roam: true,
                    label: { position: 'right', color: 'inherit' },
                    lineStyle: { curveness: 0.3, opacity: 0.4 },
                    force: { repulsion: 400, gravity: 0.1, edgeLength: 100 }
                }]
            };
            
            // Check Theme
            let isDark = document.body.classList.contains('dark');
            if(isDark) {
                option.series[0].data.forEach(n => {
                    n.itemStyle.color = (n.name === myName) ? '#00ff41' : '#00ffff';
                });
            }

            myChart.setOption(option);
            
            // Re-center "Me"
            var w = myChart.getWidth();
            var h = myChart.getHeight();
            nodes.forEach(n => {
                if (n.name === myName) { n.x = w / 2; n.y = h / 2; }
            });
            myChart.setOption({ series: [{ data: nodes }] });
        }

        // Standard Resizing & Theme Logic
        new ResizeObserver(() => myChart.resize()).observe(dom);
        
        var parentDetails = dom.closest('details');
        if (parentDetails) {
            parentDetails.addEventListener('toggle', () => {
                if(parentDetails.open) setTimeout(() => myChart.resize(), 50);
            });
        }
        
        const themeButton = document.querySelector('.js-theme-toggle');
        if(themeButton){
            themeButton.addEventListener('click', () => {
                setTimeout(() => {
                    // Simple reload to catch new colors
                    let isDark = document.body.classList.contains('dark');
                    var currentOpt = myChart.getOption();
                    if(currentOpt && currentOpt.series) {
                        currentOpt.series[0].data.forEach(n => {
                            n.itemStyle.color = (n.name === myName) 
                                ? (isDark ? '#00ff41' : '#d93025') 
                                : (isDark ? '#00ffff' : '#1a0dab');
                        });
                        myChart.setOption(currentOpt);
                    }
                }, 100);
            });
        }
    });
})();
</script>
