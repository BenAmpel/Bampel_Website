{{/* The Knowledge Graph - Context Aware (Authors + Venue + Topic) */}}
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

<div id="knowledge-graph" style="width: 100%; height: 650px; border: 1px solid var(--card-border, #333); border-radius: 8px; background: var(--card-bg, #000);" role="img" aria-label="Knowledge graph connecting publications by topic, venue, and co-authorship" tabindex="0"></div>

<script type="text/javascript">
(function() {
    var dom = document.getElementById('knowledge-graph');
    var myChart = echarts.init(dom);
    const prefersReducedMotion = window.matchMedia
        ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
        : false;
    const withReducedMotion = (option) => {
        if (!prefersReducedMotion) return option;
        return Object.assign({}, option, { animation: false, animationDuration: 0, animationDurationUpdate: 0 });
    };
    
    // Config
    const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data','from','by','detection','paper','research','towards']);
    
    const escapeHtml = (str) => String(str || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const buildCiteButtons = (meta) => {
        if (!window.buildCitationFormats) return '';
        const citations = window.buildCitationFormats({
            title: meta.name,
            authors: meta.authors,
            year: meta.year,
            venue: meta.venue,
            type: meta.type
        });
        const buttons = [
            { label: 'APA', text: citations.apa },
            { label: 'Chicago', text: citations.chicago },
            { label: 'BibTeX', text: citations.bibtex }
        ].filter(b => b.text).map(b => {
            const encoded = encodeURIComponent(b.text);
            return `<button class="cite-tooltip-btn" type="button" data-copy-text="${encoded}" data-copy-label="${b.label}">Copy ${b.label}</button>`;
        }).join('');
        return buttons ? `<div class="cite-tooltip-actions">${buttons}</div>` : '';
    };

    // Weight Tuning
    const WEIGHT_TOPIC = 1.0;
    const WEIGHT_VENUE = 2.0;
    const WEIGHT_AUTHOR = 3.0;
    const LINK_THRESHOLD = 1.5; // Minimum score to draw a line
    
    fetch('/data/scholar-metrics.json')
        .then(r => r.json())
        .then(data => {
            if(!data.individualPublications) return;
            buildGraph(data.individualPublications);
        });

    function buildGraph(papers) {
        let nodes = [];
        let links = [];

        // 1. Pre-process Nodes (Tokenize)
        papers.forEach((p, index) => {
            // A. Keywords
            let words = p.title.toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/)
                .filter(w => w.length > 3 && !STOP_WORDS.has(w));
            p._words = new Set(words);

            // B. Authors (Normalize: "S Samtani" -> "s samtani")
            p._authors = new Set();
            if(p.authors) {
                p.authors.split(',').forEach(a => {
                    let clean = a.trim().toLowerCase();
                    if(!clean.includes('ampel')) p._authors.add(clean); // Exclude self
                });
            }

            // C. Venue
            p._venue = p.venue ? p.venue.toLowerCase().trim() : "";

            nodes.push({
                id: index,
                name: p.title,
                value: p.citations || 0,
                year: p.year,
                authors: p.authors,
                venue: p.venue,
                symbolSize: Math.max(10, Math.min(65, Math.log((p.citations || 0) + 2) * 9)),
                itemStyle: { color: getColorByYear(p.year) },
                label: {
                    show: (p.citations || 0) > 15,
                    formatter: function(params) {
                        return params.name.length > 15 ? params.name.substring(0, 15) + '...' : params.name;
                    }
                }
            });
        });

        // 2. Generate Links (The "Interesting" Logic)
        for (let i = 0; i < papers.length; i++) {
            for (let j = i + 1; j < papers.length; j++) {
                let p1 = papers[i];
                let p2 = papers[j];
                let score = 0;
                let reasons = [];

                // Check Topic
                let commonWords = 0;
                p1._words.forEach(w => { if (p2._words.has(w)) commonWords++; });
                if (commonWords > 0) {
                    score += (commonWords * WEIGHT_TOPIC);
                    reasons.push(`${commonWords} Keywords`);
                }

                // Check Venue
                if (p1._venue && p2._venue && p1._venue === p2._venue) {
                    score += WEIGHT_VENUE;
                    reasons.push("Same Venue");
                }

                // Check Authors
                let commonAuthors = 0;
                p1._authors.forEach(a => { if (p2._authors.has(a)) commonAuthors++; });
                if (commonAuthors > 0) {
                    score += (commonAuthors * WEIGHT_AUTHOR);
                    reasons.push(`${commonAuthors} Co-Authors`);
                }

                // Create Link if meaningful
                if (score >= LINK_THRESHOLD) {
                    let avgCites = ((p1.citations || 0) + (p2.citations || 0)) / 2;
                    let impactBonus = Math.log(avgCites + 1) * 1.5;

                    links.push({
                        source: i,
                        target: j,
                        value: score + impactBonus, // Physics pull strength
                        reason: reasons.join(", "), // For tooltip
                        lineStyle: {
                            width: Math.min((score * 0.5) + impactBonus, 5),
                            opacity: Math.min(0.15 + (score * 0.1), 0.7),
                            curveness: 0.2
                        }
                    });
                }
            }
        }

        renderChart(nodes, links);
    }

    function getColorByYear(year) {
        let y = parseInt(year) || 2022;
        if (y < 2020) return '#e040fb'; // Purple (Past)
        if (y < 2023) return '#00e5ff'; // Cyan (Recent)
        return '#00ff41';               // Green (Current)
    }

    function renderChart(nodes, links) {
        let isDark = document.body.classList.contains('dark');
        
        let option = withReducedMotion({
            backgroundColor: 'transparent',
            tooltip: {
                enterable: true,
                extraCssText: 'pointer-events:auto; max-width:320px;',
                formatter: (params) => {
                        if (params.dataType === 'edge') {
                            return `<strong>Connection Strength:</strong> ${Math.floor(params.value)}<br>Link: ${params.data.reason}`;
                        }
                        const citeButtons = buildCiteButtons(params.data || {});
                        return `<strong>${escapeHtml(params.name)}</strong><br>
                            Year: ${escapeHtml(params.data.year)}<br>
                            Citations: ${params.value}<br>
                            <span style="font-size:0.8em; opacity:0.8">${escapeHtml(params.data.venue || '')}</span>
                            ${citeButtons}`;
                    }
                },
            aria: { enabled: true, description: 'Knowledge graph showing relationships between publications.' },
            series: [{
                type: 'graph',
                layout: 'force',
                data: nodes,
                links: links,
                roam: true,
                zoom: 0.75,
                label: { position: 'right', color: 'inherit' },
                lineStyle: { color: isDark ? '#aaa' : '#666' },
                force: {
                    initLayout: 'circular',
                    repulsion: 500,
                    gravity: 0.1,
                    edgeLength: [50, 300],
                    friction: 0.9
                }
            }]
        });

        myChart.setOption(option);

        // Theme Listener
        const btn = document.querySelector('.js-theme-toggle');
        if(btn) {
            btn.addEventListener('click', () => {
                setTimeout(() => {
                    let isDarkNow = document.body.classList.contains('dark');
                    myChart.setOption({
                        series: [{ lineStyle: { color: isDarkNow ? '#aaa' : '#666' } }]
                    });
                }, 100);
            });
        }
        window.addEventListener('resize', () => myChart.resize());
    }
})();
</script>
