<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

<div id="dashboard-wrapper" style="min-height:1300px; margin:30px 0; font-family:sans-serif;">
<div style="display:grid; grid-template-columns:1fr 1fr; grid-template-rows:auto 600px 600px 300px; gap:0; border:1px solid var(--card-border, #333); border-radius:12px; overflow:hidden; background:var(--card-bg, rgba(255,255,255,0.02)); box-shadow:0 4px 20px rgba(0,0,0,0.1);">

<div style="grid-column:1; grid-row:1; padding:20px; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333);">
    <h4 style="margin:0 0 10px; opacity:0.7; text-align:center; text-transform:uppercase; font-size:0.8rem;">Research Profile Topics</h4>
    <div id="dashboard-topics" class="profile-topics"></div>
    <div class="profile-topics-note">Topic model inferred from academic outputs in the CV.</div>
</div>

<div style="grid-column:2; grid-row:1; padding:25px; border-bottom:1px solid var(--card-border, #333); display:flex; flex-direction:column;">
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
        <div><div style="font-size:0.75rem; opacity:0.6;">Primary Focus</div><div id="dash-metric-focus" style="font-size:1rem; font-weight:800; color:#00ff41; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">Emerging Focus</div><div id="dash-metric-trend" style="font-size:1rem; font-weight:800; color:#00e5ff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">Total Citations</div><div id="dash-metric-cites" style="font-size:1.4rem; font-weight:800; color:#e040fb;">0</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">h-index</div><div id="dash-metric-hindex" style="font-size:1.4rem; font-weight:800; opacity:0.9;">0</div></div>
    </div>
    <div style="flex-grow:1; border-top:1px solid var(--card-border, #333); padding-top:15px; position:relative;">
        <h4 style="margin:0 0 5px; font-size:0.7rem; opacity:0.5; text-transform:uppercase;">Citation Velocity</h4>
        <div id="dashboard-timeline" style="width:100%; height:160px;"></div>
    </div>
</div>

<div style="grid-column:1; grid-row:2; padding:0; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; left:20px; z-index:10; pointer-events:none;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase;">Impact Map</h4>
        <p style="margin:0; font-size:0.65rem; opacity:0.5;">Connections by Topic, Venue & Co-authors</p>
    </div>
    <div class="impact-map-controls" aria-label="Impact map controls">
        <div class="impact-control-group" role="group" aria-label="Color mode">
            <button class="impact-toggle is-active" data-impact-color="topic" type="button">Color: Topic</button>
            <button class="impact-toggle" data-impact-color="year" type="button">Color: Year</button>
        </div>
        <div class="impact-control-group" role="group" aria-label="Connection types">
            <label class="impact-check"><input type="checkbox" data-impact-link="topic" checked> Topics</label>
            <label class="impact-check"><input type="checkbox" data-impact-link="venue" checked> Venues</label>
            <label class="impact-check"><input type="checkbox" data-impact-link="author" checked> Co-authors</label>
        </div>
    </div>
    <div class="impact-map-legend" id="impact-map-legend"></div>
    <div class="impact-map-inspector" id="impact-map-inspector" aria-live="polite">
        <div class="impact-inspector-title">Focus lens</div>
        <div class="impact-inspector-body">Click a node to reveal context, then pin highlights you want to keep.</div>
        <div class="impact-inspector-actions">
            <button class="impact-action" type="button" data-impact-action="pin" disabled>Pin highlight</button>
            <button class="impact-action" type="button" data-impact-action="clear" disabled>Clear focus</button>
        </div>
        <div class="impact-inspector-pins" id="impact-map-pins"></div>
    </div>
    <div id="dashboard-impact-map" style="width:100%; height:100%;"></div>
</div>

<div style="grid-column:2; grid-row:2; padding:25px; border-bottom:1px solid var(--card-border, #333); display:flex; flex-direction:column; height:100%; overflow:hidden;">
    <div class="centrality-header">
        <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin:0;">Network Centrality Analysis</h4>
        <div class="centrality-tabs" role="tablist">
            <button class="centrality-tab is-active" data-centrality-tab="eigen" type="button" role="tab" aria-selected="true">Influence</button>
            <button class="centrality-tab" data-centrality-tab="between" type="button" role="tab" aria-selected="false">Bridges</button>
            <button class="centrality-tab" data-centrality-tab="degree" type="button" role="tab" aria-selected="false">Hubs</button>
        </div>
    </div>
    <div class="centrality-metrics">
        <div class="centrality-metric"><span>Density</span><strong id="centrality-density">--</strong></div>
        <div class="centrality-metric"><span>Avg Path</span><strong id="centrality-path">--</strong></div>
        <div class="centrality-metric"><span>Clustering</span><strong id="centrality-cluster">--</strong></div>
    </div>
    <div class="centrality-body">
        <div class="centrality-list" id="centrality-list">
            <span style="opacity:0.3;">Calculating...</span>
        </div>
        <div class="centrality-side">
            <div class="centrality-side-title">Cohesion Radar</div>
            <div id="centrality-radar" style="width:100%; height:160px;"></div>
            <div class="centrality-side-note" id="centrality-note">Hover a paper to see how it connects across topic, venue, and co-author links.</div>
        </div>
    </div>
</div>

<div style="grid-column:1; grid-row:3; padding:0; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; left:20px; z-index:10; pointer-events:none;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase;">Collaboration Network</h4>
        <p style="margin:0; font-size:0.65rem; opacity:0.5;">Co-authorship Connections</p>
    </div>
    <div class="collab-controls" aria-label="Collaboration filters">
        <div class="collab-chip-row" role="group" aria-label="Year range">
            <button class="collab-chip is-active" data-collab-range="all" type="button">All-time</button>
            <button class="collab-chip" data-collab-range="5" type="button">Last 5 yrs</button>
            <button class="collab-chip" data-collab-range="3" type="button">Last 3 yrs</button>
            <button class="collab-chip" data-collab-range="2" type="button">Last 2 yrs</button>
        </div>
    </div>
    <div class="collab-spotlight" id="collab-spotlight" aria-live="polite">
        <div class="collab-spotlight-title">Collaborator spotlight</div>
        <div class="collab-spotlight-body">Select a node to see their co-authorship footprint, top venues, and key connections.</div>
        <div class="collab-spotlight-meta" id="collab-spotlight-meta"></div>
    </div>
    <div id="dashboard-collab-network" style="width:100%; height:100%;"></div>
</div>

<div style="grid-column:2; grid-row:3; padding:0; border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; right:20px; z-index:400; pointer-events:none; text-align:right;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase; color:#333; text-shadow:0 0 5px white;">Research Footprint</h4>
    </div>
    <div class="footprint-controls" aria-label="Footprint controls">
        <div class="footprint-group" role="group" aria-label="Categories">
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Conference" checked> Conferences</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Institution" checked> Institutions</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Collaboration" checked> Collaborations</label>
        </div>
        <div class="footprint-group" role="group" aria-label="Layers">
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="routes" checked> Routes</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="heat" checked> Heat</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="clusters" checked> Clusters</label>
        </div>
        <div class="footprint-group footprint-timeline" role="group" aria-label="Timeline">
            <span class="footprint-year-label" id="footprint-year-label">Up to —</span>
            <input type="range" id="footprint-year-range" min="2018" max="2026" value="2026" step="1" />
        </div>
    </div>
    <div class="footprint-legend" id="footprint-legend"></div>
    <div id="dashboard-footprint-map" style="width:100%; height:100%; z-index:1;"></div>
</div>

<div style="grid-column:1; grid-row:4; padding:25px; border-right:1px solid var(--card-border, #333); display:flex; flex-direction:column;">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:15px;">
        <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin:0;">Traffic Overview</h4>
        <div id="dash-visit-momentum" class="dash-momentum">--</div>
    </div>
    <div style="display:flex; gap:20px; height:100%;">
        <div style="flex:0 0 100px; display:flex; flex-direction:column; justify-content:center;">
            <div style="margin-bottom:15px;">
                <div style="font-size:0.7rem; opacity:0.6;">Total Visitors</div>
                <div id="dash-visit-total" style="font-size:1.4rem; font-weight:800; color:#00ff41;">0</div>
            </div>
            <div>
                <div style="font-size:0.7rem; opacity:0.6;">Last 30 Days</div>
                <div id="dash-visit-month" style="font-size:1.4rem; font-weight:800; color:#00e5ff;">0</div>
            </div>
        </div>
        <div style="flex-grow:1; position:relative;">
            <div id="dash-visit-trend" style="width:100%; height:100%;"></div>
        </div>
    </div>
</div>

<div style="grid-column:2; grid-row:4; padding:25px; display:flex; flex-direction:column;">
    <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin-bottom:15px;">Audience & Reach</h4>
    <div style="display:flex; gap:20px; height:100%;">
        <div style="flex:1; display:flex; flex-direction:column; gap:12px;">
            <div id="dash-visit-geo" class="dash-geo-mix"></div>
            <div id="dash-visit-minimap" class="dash-mini-map">
                <div class="dash-mini-map-inner"></div>
                <div class="dash-mini-map-fallback">Global footprint preview</div>
            </div>
        </div>
        <div style="flex:1; overflow-y:auto; border-left:1px solid var(--card-border, #333); padding-left:15px; display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; align-items:center; justify-content:space-between;">
                <div style="font-size:0.7rem; font-weight:bold; opacity:0.8;">Top 5 Locations</div>
                <div id="dash-visit-region" class="dash-region-badge">Top Region: —</div>
            </div>
            <div id="dash-visit-locations" class="dash-location-list">
                <span style="opacity:0.5;">Loading...</span>
            </div>
        </div>
    </div>
</div>

</div>
</div>

<style>
/* Leaflet Markers */
.custom-marker { background: transparent; }
.custom-marker .marker-pin { width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 4px rgba(0,0,0,0.3); }
.conference-marker .marker-pin { background: #00ff41; }
.collaboration-marker .marker-pin { background: #00bfff; }
.institution-marker .marker-pin { background: #ff6b35; }
body.dark .custom-marker .marker-pin { border-color: #000; box-shadow: 0 0 8px currentColor; }

/* Impact map controls */
.impact-map-controls { position:absolute; top:16px; right:16px; z-index:20; display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
.impact-control-group { display:flex; flex-wrap:wrap; gap:6px; padding:6px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.impact-toggle { border:1px solid rgba(0,255,65,0.3); background:transparent; color:#b9f6ca; font-size:0.6rem; letter-spacing:0.05em; text-transform:uppercase; padding:4px 8px; border-radius:999px; cursor:pointer; }
.impact-toggle.is-active { background:rgba(0,255,65,0.18); border-color:#00ff41; color:#00ff41; }
.impact-check { display:flex; align-items:center; gap:6px; font-size:0.62rem; color:#cfead2; }
.impact-check input { accent-color:#00ff41; }
.impact-map-legend { position:absolute; bottom:14px; left:14px; z-index:15; max-width:240px; background:rgba(0,0,0,0.4); border:1px solid var(--card-border, #333); border-radius:12px; padding:8px 10px; font-size:0.62rem; color:#d6dde2; backdrop-filter: blur(6px); pointer-events:auto; }
.impact-map-legend .legend-row { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
.impact-map-legend .legend-row:last-child { margin-bottom:0; }
.impact-legend-dot { width:8px; height:8px; border-radius:50%; background:var(--legend-color); box-shadow:0 0 6px rgba(0,0,0,0.4); }
.impact-map-inspector { position:absolute; top:92px; right:16px; width:230px; z-index:20; background:rgba(0,0,0,0.48); border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; font-size:0.62rem; color:#e0e0e0; backdrop-filter: blur(6px); pointer-events:auto; }
.impact-inspector-title { font-size:0.68rem; text-transform:uppercase; opacity:0.7; margin-bottom:6px; }
.impact-inspector-body { line-height:1.4; margin-bottom:8px; opacity:0.9; }
.impact-inspector-actions { display:flex; gap:6px; margin-bottom:8px; }
.impact-action { flex:1; border-radius:999px; border:1px solid rgba(0,255,65,0.3); background:transparent; color:#c8f7c5; font-size:0.58rem; padding:4px 6px; text-transform:uppercase; letter-spacing:0.08em; cursor:pointer; }
.impact-action:disabled { opacity:0.4; cursor:not-allowed; }
.impact-inspector-pins { display:flex; flex-wrap:wrap; gap:6px; }
.impact-pin { display:flex; align-items:center; gap:6px; padding:4px 6px; border-radius:999px; background:rgba(0,229,255,0.12); border:1px solid rgba(0,229,255,0.3); font-size:0.58rem; }
.impact-pin button { border:none; background:transparent; color:#00e5ff; cursor:pointer; font-size:0.7rem; line-height:1; }

/* Collaboration network controls */
.collab-controls { position:absolute; top:16px; right:16px; z-index:20; pointer-events:auto; }
.collab-chip-row { display:flex; flex-wrap:wrap; gap:6px; padding:6px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.collab-chip { border:1px solid rgba(0,229,255,0.3); background:transparent; color:#bde8ff; font-size:0.6rem; letter-spacing:0.04em; text-transform:uppercase; padding:4px 8px; border-radius:999px; cursor:pointer; }
.collab-chip.is-active { background:rgba(0,229,255,0.18); border-color:#00e5ff; color:#00e5ff; }
.collab-spotlight { position:absolute; bottom:16px; left:16px; width:240px; z-index:20; background:rgba(0,0,0,0.48); border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; font-size:0.62rem; color:#e0e0e0; backdrop-filter: blur(6px); pointer-events:auto; }
.collab-spotlight-title { font-size:0.68rem; text-transform:uppercase; opacity:0.7; margin-bottom:6px; }
.collab-spotlight-body { line-height:1.4; margin-bottom:8px; opacity:0.9; }
.collab-spotlight-meta { display:grid; gap:6px; }
.collab-meta-row { display:flex; justify-content:space-between; gap:10px; }
.collab-meta-row span { opacity:0.7; }
.collab-meta-row strong { font-weight:700; color:#00e5ff; }

@media (max-width: 900px) {
    .impact-map-controls { top:12px; right:12px; }
    .impact-map-legend { bottom:12px; left:12px; }
    .impact-map-inspector { top:auto; bottom:12px; right:12px; width:200px; }
    .collab-controls { top:12px; right:12px; }
    .collab-spotlight { bottom:12px; left:12px; width:210px; }
}

body:not(.dark) .impact-control-group,
body:not(.dark) .impact-map-legend,
body:not(.dark) .impact-map-inspector,
body:not(.dark) .collab-chip-row,
body:not(.dark) .collab-spotlight {
    background:rgba(255,255,255,0.85);
    color:#333;
    border-color:#e0e0e0;
}
body:not(.dark) .impact-toggle,
body:not(.dark) .impact-action,
body:not(.dark) .collab-chip { color:#1a1a1a; border-color:#bdbdbd; }
body:not(.dark) .impact-toggle.is-active { color:#0b7a2f; border-color:#0b7a2f; background:rgba(11,122,47,0.15); }
body:not(.dark) .collab-chip.is-active { color:#0077b6; border-color:#0077b6; background:rgba(0,119,182,0.15); }
body:not(.dark) .impact-action { color:#0b7a2f; }
body:not(.dark) .impact-pin { background:rgba(0,119,182,0.12); border-color:rgba(0,119,182,0.3); }

/* Footprint map controls */
.footprint-controls { position:absolute; top:16px; left:16px; z-index:20; display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
.footprint-group { display:flex; flex-wrap:wrap; gap:8px; padding:6px 8px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.footprint-check { display:flex; align-items:center; gap:6px; font-size:0.62rem; color:#cfead2; }
.footprint-check input { accent-color:#00e5ff; }
.footprint-timeline { flex-direction:column; align-items:flex-start; gap:6px; }
.footprint-year-label { font-size:0.62rem; letter-spacing:0.04em; text-transform:uppercase; color:#bde8ff; }
.footprint-timeline input[type="range"] { width:200px; }
.footprint-legend { position:absolute; bottom:14px; right:14px; z-index:15; max-width:200px; background:rgba(0,0,0,0.4); border:1px solid var(--card-border, #333); border-radius:12px; padding:8px 10px; font-size:0.62rem; color:#d6dde2; backdrop-filter: blur(6px); pointer-events:none; }
.footprint-legend .legend-row { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
.footprint-legend .legend-row:last-child { margin-bottom:0; }
.footprint-legend-dot { width:8px; height:8px; border-radius:50%; background:var(--legend-color); box-shadow:0 0 6px rgba(0,0,0,0.4); }

.footprint-marker { position:relative; width:16px; height:16px; }
.footprint-marker .ring { position:absolute; inset:-6px; border-radius:50%; border:1.5px solid currentColor; opacity:0.6; animation: footprintPulse 2.6s ease-out infinite; }
.footprint-marker .dot { position:absolute; inset:0; border-radius:50%; background:currentColor; box-shadow:0 0 6px rgba(0,0,0,0.5); }
.footprint-marker.conference { color:#00ff41; }
.footprint-marker.institution { color:#ff6b35; }
.footprint-marker.collaboration { color:#00bfff; }

.footprint-arc { stroke:#00e5ff; stroke-width:1.2; stroke-opacity:0.4; stroke-dasharray:6 10; animation: arcDash 6s linear infinite; }

.marker-cluster-small { background:rgba(0,229,255,0.15) !important; }
.marker-cluster-small div { background:rgba(0,229,255,0.35) !important; color:#0c1f2a !important; }
.marker-cluster-medium { background:rgba(0,255,65,0.15) !important; }
.marker-cluster-medium div { background:rgba(0,255,65,0.35) !important; color:#0c1f2a !important; }
.marker-cluster-large { background:rgba(224,64,251,0.15) !important; }
.marker-cluster-large div { background:rgba(224,64,251,0.35) !important; color:#0c1f2a !important; }

@keyframes footprintPulse { 0% { transform:scale(0.7); opacity:0.6; } 70% { transform:scale(1.6); opacity:0; } 100% { opacity:0; } }
@keyframes arcDash { to { stroke-dashoffset: -32; } }

body:not(.dark) .footprint-group,
body:not(.dark) .footprint-legend { background:rgba(255,255,255,0.9); color:#333; border-color:#e0e0e0; }
body:not(.dark) .footprint-year-label { color:#0b4f6c; }

@media (max-width: 900px) {
    .footprint-controls { top:12px; left:12px; }
    .footprint-legend { bottom:12px; right:12px; }
    .footprint-timeline input[type="range"] { width:160px; }
}

/* Traffic Overview + Audience styling */
.dash-momentum { font-size:0.6rem; text-transform:uppercase; letter-spacing:0.08em; padding:4px 10px; border-radius:999px; border:1px solid rgba(0,255,65,0.25); color:#b9f6ca; background:rgba(0,255,65,0.08); display:flex; align-items:center; gap:6px; }
.dash-momentum.is-up { border-color:#00ff41; color:#00ff41; }
.dash-momentum.is-down { border-color:#ff6b35; color:#ff6b35; }
.dash-momentum.is-flat { border-color:#bdbdbd; color:#bdbdbd; }
.dash-momentum span { font-weight:700; }

.dash-geo-mix { display:flex; flex-direction:column; gap:6px; padding:8px 10px; border-radius:12px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.3); font-size:0.62rem; color:#d6dde2; }
.dash-geo-bar { width:100%; height:8px; border-radius:999px; background:rgba(255,255,255,0.08); overflow:hidden; display:flex; }
.dash-geo-bar span { height:100%; display:block; }
.dash-geo-us { background:#00ff41; }
.dash-geo-intl { background:#00e5ff; }
.dash-geo-labels { display:flex; justify-content:space-between; gap:8px; font-size:0.6rem; text-transform:uppercase; letter-spacing:0.05em; }

.dash-mini-map { height:110px; border-radius:12px; border:1px solid var(--card-border, #333); overflow:hidden; background:rgba(0,0,0,0.25); }
.dash-mini-map { min-height:110px; flex:0 0 110px; position:relative; }
.dash-mini-map-inner { position:absolute; inset:0; }
.dash-mini-map-fallback { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:0.6rem; letter-spacing:0.08em; text-transform:uppercase; color:rgba(255,255,255,0.55); background:radial-gradient(circle at top, rgba(0,229,255,0.1), transparent 70%); }
.dash-mini-map.is-ready .dash-mini-map-fallback { opacity:0; pointer-events:none; }
.dash-mini-map .leaflet-container { width:100%; height:100%; }

.dash-region-badge { font-size:0.58rem; text-transform:uppercase; letter-spacing:0.06em; color:#00e5ff; padding:4px 8px; border-radius:999px; border:1px solid rgba(0,229,255,0.35); background:rgba(0,229,255,0.12); }

.dash-location-list { display:flex; flex-direction:column; gap:8px; }
.dash-location-row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
.dash-location-bar { flex:1; height:6px; border-radius:999px; background:rgba(255,255,255,0.08); overflow:hidden; }
.dash-location-bar span { display:block; height:100%; background:#e040fb; }
.dash-location-name { font-size:0.72rem; opacity:0.8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:140px; }
.dash-location-count { font-weight:700; color:#e040fb; font-size:0.72rem; }

body:not(.dark) .dash-geo-mix { background:rgba(255,255,255,0.85); color:#333; border-color:#e0e0e0; }
body:not(.dark) .dash-momentum { background:rgba(11,122,47,0.1); color:#0b7a2f; border-color:#0b7a2f; }
body:not(.dark) .dash-region-badge { color:#0077b6; border-color:#0077b6; background:rgba(0,119,182,0.12); }

/* Centrality panel */
.centrality-header { display:flex; align-items:center; justify-content:space-between; gap:10px; padding-bottom:10px; border-bottom:1px solid var(--card-border, #444); margin-bottom:10px; }
.centrality-tabs { display:flex; gap:6px; }
.centrality-tab { border:1px solid rgba(0,229,255,0.35); background:transparent; color:#bde8ff; font-size:0.6rem; letter-spacing:0.06em; text-transform:uppercase; padding:4px 8px; border-radius:999px; cursor:pointer; }
.centrality-tab.is-active { background:rgba(0,229,255,0.18); border-color:#00e5ff; color:#00e5ff; }

.centrality-metrics { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:8px; margin-bottom:10px; }
.centrality-metric { border:1px solid var(--card-border, #333); border-radius:10px; padding:8px; background:rgba(0,0,0,0.25); display:flex; flex-direction:column; gap:4px; font-size:0.6rem; text-transform:uppercase; letter-spacing:0.04em; color:#cfead2; }
.centrality-metric strong { font-size:0.9rem; color:#00ff41; text-transform:none; letter-spacing:0; }
.centrality-metric:nth-child(2) strong { color:#00e5ff; }
.centrality-metric:nth-child(3) strong { color:#e040fb; }

.centrality-body { display:grid; grid-template-columns:1.1fr 0.9fr; gap:12px; flex-grow:1; min-height:0; }
.centrality-list { overflow-y:auto; padding-right:6px; display:flex; flex-direction:column; gap:10px; }
.centrality-item { border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; background:rgba(0,0,0,0.22); position:relative; overflow:hidden; cursor:pointer; transition:transform 0.15s ease, border-color 0.15s ease; }
.centrality-item:hover { transform:translateY(-2px); border-color:rgba(0,229,255,0.5); }
.centrality-bar { position:absolute; left:0; top:0; bottom:0; width:0; background:linear-gradient(90deg, rgba(0,229,255,0.22), rgba(0,255,65,0.12)); opacity:0.35; transition:width 0.4s ease; }
.centrality-item-header { display:flex; align-items:flex-start; justify-content:space-between; gap:8px; position:relative; z-index:1; }
.centrality-rank { font-size:0.8rem; font-weight:700; color:#00e5ff; min-width:20px; }
.centrality-main { flex:1; min-width:0; }
.centrality-title { font-size:0.75rem; line-height:1.3; font-weight:600; color:#f3f8ff; margin:0; }
.centrality-meta { font-size:0.6rem; opacity:0.7; margin-top:4px; display:flex; gap:8px; flex-wrap:wrap; }
.centrality-badges { display:flex; gap:6px; align-items:center; }
.centrality-sidebits { display:flex; flex-direction:column; align-items:flex-end; gap:6px; }
.centrality-badge { font-size:0.55rem; text-transform:uppercase; letter-spacing:0.06em; padding:2px 6px; border-radius:999px; background:rgba(224,64,251,0.15); color:#e040fb; border:1px solid rgba(224,64,251,0.3); }
.centrality-pills { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
.centrality-pill { font-size:0.55rem; text-transform:uppercase; letter-spacing:0.06em; padding:2px 6px; border-radius:999px; background:rgba(0,255,65,0.12); color:#b9f6ca; border:1px solid rgba(0,255,65,0.3); }
.centrality-sparkline { width:90px; height:26px; }
.centrality-side { border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; background:rgba(0,0,0,0.2); display:flex; flex-direction:column; gap:8px; }
.centrality-side-title { font-size:0.7rem; text-transform:uppercase; letter-spacing:0.08em; color:#bde8ff; }
.centrality-side-note { font-size:0.6rem; opacity:0.7; line-height:1.4; }

body:not(.dark) .centrality-metric,
body:not(.dark) .centrality-item,
body:not(.dark) .centrality-side { background:rgba(255,255,255,0.9); border-color:#e0e0e0; color:#333; }
body:not(.dark) .centrality-title { color:#1a1a1a; }
body:not(.dark) .centrality-tab { color:#0077b6; border-color:#0077b6; }
body:not(.dark) .centrality-tab.is-active { background:rgba(0,119,182,0.15); }

@media (max-width: 900px) {
    .centrality-metrics { grid-template-columns:repeat(2, minmax(0,1fr)); }
    .centrality-body { grid-template-columns:1fr; }
}

/* Research profile topics */
.profile-topics { display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px; }
.profile-topic-card { border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; background:rgba(0,0,0,0.2); display:flex; flex-direction:column; gap:6px; }
.profile-topic-header { display:flex; align-items:center; justify-content:space-between; gap:6px; }
.profile-topic-title { font-size:0.72rem; font-weight:600; color:#f3f8ff; text-transform:uppercase; letter-spacing:0.05em; }
.profile-topic-weight { font-size:0.6rem; color:#00e5ff; }
.profile-topic-terms { font-size:0.6rem; opacity:0.7; line-height:1.4; }
.profile-topic-bar { height:6px; border-radius:999px; background:rgba(255,255,255,0.1); overflow:hidden; }
.profile-topic-bar span { display:block; height:100%; background:linear-gradient(90deg, rgba(0,255,65,0.9), rgba(0,229,255,0.8)); }
.profile-topics-note { margin-top:8px; font-size:0.6rem; opacity:0.6; text-align:center; }

body:not(.dark) .profile-topic-card { background:rgba(255,255,255,0.9); border-color:#e0e0e0; }
body:not(.dark) .profile-topic-title { color:#1a1a1a; }
</style>

<script type="text/javascript">
(function() {
    // 1. IDS configuration
    const IDS = {
        LINE: 'dashboard-timeline',
        MAP: 'dashboard-impact-map',
        COLLAB: 'dashboard-collab-network',
        FOOTPRINT: 'dashboard-footprint-map',
        TOPICS: 'dashboard-topics',
        VISIT: {
            TREND: 'dash-visit-trend',
            DEVICE: 'dash-visit-device',
            TOTAL: 'dash-visit-total',
            MONTH: 'dash-visit-month',
            LOCS: 'dash-visit-locations'
        },
        METRICS: {
            FOCUS: 'dash-metric-focus', TREND: 'dash-metric-trend',
            CITES: 'dash-metric-cites', HINDEX: 'dash-metric-hindex'
        },
        LISTS: { EIGEN: 'dash-list-eigen', BETWEEN: 'dash-list-between', DEGREE: 'dash-list-degree' }
    };

    const TOPIC_TAXONOMY = {
        'AI / Deep Learning': ['Deep Learning', 'Neural', 'Transfer Learning', 'Embedding', 'Machine Learning', 'Artificial Intelligence', 'Adversarial'],
        'Cybersecurity': ['Cyber', 'Vulnerability', 'Exploit', 'Attack', 'Threat', 'Security', 'Malicious', 'Ransomware', 'Phishing'],
        'LLMs & NLP': ['Large Language Model', 'LLM', 'Text Analytics', 'NLP', 'Transformer', 'Bert', 'GPT', 'Language Models'],
        'Hacker Communities': ['Hacker', 'Forum', 'Dark Web', 'Paste', 'Community', 'Marketplace', 'Underground'],
        'Design Science': ['Design Science', 'Framework', 'Artifact', 'System', 'Implementation', 'Prototyping'],
        'Behavioral': ['Nudging', 'Bias', 'Social', 'Human', 'Behavior', 'Psychology', 'Decision', 'Trust']
    };

    const impactState = {
        colorMode: 'topic',
        linkTypes: { topic: true, venue: true, author: true },
        focusId: null,
        pinned: new Set()
    };

    let collabRange = 'all';
    let collabFocusId = null;

    var lineChart, graphChart, collabChart, visitTrendChart, visitDeviceChart, centralityRadarChart, footprintMap;

    // 2. DATA LOADING
    const safeFetch = (url) => fetch(url).then(r => r.ok ? r.json() : null).catch(e => null);

    Promise.all([
        safeFetch('/data/publications.json'),
        safeFetch('/data/scholar-metrics.json'),
        safeFetch('/data/visitor_stats.json'),
        safeFetch('/data/cv_topics.json')
    ]).then(([papersData, scholarData, visitorData, cvTopics]) => {
        
        let papers = [];
        if (scholarData && scholarData.individualPublications) {
            papers = scholarData.individualPublications;
        } else if (papersData) {
            papers = Array.isArray(papersData) ? papersData : (papersData.individualPublications || []);
        }

        processMetrics(papers, scholarData);

        if(scholarData && scholarData.citationsByYear) renderLine(scholarData.citationsByYear);
        renderWorkingMap(papers); 
        calculateAllMetrics(papers);
        renderCollabNetwork(papers);
        renderFootprintMap();
        renderCvTopics(cvTopics);
        
        if(visitorData) renderVisitorStats(visitorData);

    }).catch(err => console.error("Dashboard Error:", err));


    // ========================================================================
    // LOGIC: VISITOR STATS (Row 4)
    // ========================================================================
    function renderVisitorStats(data) {
        updateText(IDS.VISIT.TOTAL, data.lifetime_total || 0);
        updateText(IDS.VISIT.MONTH, data.total_last_30_days || 0);
        const regionEl = document.getElementById('dash-visit-region');
        if (regionEl) regionEl.textContent = 'Top Region: Global';

        // 1. Trend Chart
        var domTrend = document.getElementById(IDS.VISIT.TREND);
        if(domTrend && data.monthly_trend) {
            if(visitTrendChart) visitTrendChart.dispose();
            visitTrendChart = echarts.init(domTrend);
            
            let months = data.monthly_trend.map(d => d.month);
            let counts = data.monthly_trend.map(d => d.visitors);
            let maxVal = Math.max(...counts, 0);

            const formatMonth = (val) => {
                if (!val) return '';
                const str = String(val);
                if (str.length === 6) {
                    const year = str.slice(0, 4);
                    const month = str.slice(4);
                    const date = new Date(Number(year), Number(month) - 1, 1);
                    return date.toLocaleString('en-US', { month: 'short', year: '2-digit' });
                }
                return val;
            };
            let labels = months.map(formatMonth);
            let barData = counts.map(v => ({
                value: v,
                itemStyle: { color: v === maxVal ? '#00ff41' : '#00c853' }
            }));
            
            visitTrendChart.setOption({
                tooltip: { trigger: 'axis', formatter: params => {
                    const barPoint = params.find(p => p.seriesType === 'bar') || params[0];
                    const val = (barPoint.data && barPoint.data.value !== undefined) ? barPoint.data.value : barPoint.data;
                    return `${barPoint.axisValueLabel}: ${val} visitors`;
                }},
                grid: { top: 10, right: 10, bottom: 20, left: 10, containLabel: false },
                xAxis: { show: false, data: labels },
                yAxis: { show: false, type: 'value' },
                series: [{
                    type: 'bar',
                    data: barData,
                    itemStyle: { borderRadius: [2,2,0,0] },
                    barWidth: '60%'
                },
                {
                    type: 'line',
                    data: counts,
                    smooth: true,
                    symbol: 'circle',
                    symbolSize: 4,
                    lineStyle: { color: '#00e5ff', width: 2 },
                    itemStyle: { color: '#00e5ff' },
                    areaStyle: { color: 'rgba(0,229,255,0.15)' }
                }]
            });

            const momentumEl = document.getElementById('dash-visit-momentum');
            if (momentumEl) {
                const sorted = data.monthly_trend.slice().sort((a,b) => String(a.month).localeCompare(String(b.month)));
                let label = 'vs last month';
                let valueText = '—';
                let cls = 'dash-momentum is-flat';
                if (sorted.length >= 2) {
                    const last = sorted[sorted.length - 1].visitors || 0;
                    const prev = sorted[sorted.length - 2].visitors || 0;
                    if (prev === 0 && last > 0) {
                        valueText = '+100%';
                        cls = 'dash-momentum is-up';
                    } else if (prev === 0 && last === 0) {
                        valueText = '0%';
                        cls = 'dash-momentum is-flat';
                    } else {
                        const change = ((last - prev) / prev) * 100;
                        const sign = change > 0 ? '+' : '';
                        valueText = `${sign}${change.toFixed(0)}%`;
                        cls = change > 1 ? 'dash-momentum is-up' : (change < -1 ? 'dash-momentum is-down' : 'dash-momentum is-flat');
                    }
                }
                momentumEl.className = cls;
                momentumEl.innerHTML = `<span>${valueText}</span><span>${label}</span>`;
            }
        }

        // 2. Device Chart
        var domDevice = document.getElementById(IDS.VISIT.DEVICE);
        if(domDevice && data.devices) {
            if(visitDeviceChart) visitDeviceChart.dispose();
            visitDeviceChart = echarts.init(domDevice);
            let isDark = document.body.classList.contains('dark');
            
            visitDeviceChart.setOption({
                tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                series: [{
                    type: 'pie',
                    radius: ['40%', '70%'],
                    center: ['50%', '50%'],
                    itemStyle: { borderRadius: 4, borderColor: isDark?'#111':'#fff', borderWidth: 2 },
                    label: { show: true, position: 'inside', formatter: p => `${Math.round(p.percent)}%`, color: isDark ? '#fff' : '#111', fontSize: 11 },
                    labelLine: { show: false },
                    data: data.devices.map(d => ({ name: d.device, value: d.users }))
                }]
            });
        }

        // 3. Top Locations (Filtered Logic)
        var domLocs = document.getElementById(IDS.VISIT.LOCS);
        if(domLocs) {
            // Prioritize 'top_locations' which contains city/country
            let rawList = data.top_locations || data.countries || data.locations || [];
            
            // FIX: Filter empty or "(not set)" values
            const isValid = (value) => value && value.trim() !== "" && value !== "(not set)";
            let list = rawList.filter(d => isValid(d.city) && isValid(d.country));
            
            // Sort by visitors or users
            list.sort((a,b) => (b.visitors || b.users || 0) - (a.visitors || a.users || 0));
            
            // Top 5
            let top5 = list.slice(0, 5);

            if(top5.length > 0) {
                const stateMap = {
                    "Alabama":"AL","Alaska":"AK","Arizona":"AZ","Arkansas":"AR","California":"CA","Colorado":"CO","Connecticut":"CT","Delaware":"DE",
                    "District of Columbia":"DC","Florida":"FL","Georgia":"GA","Hawaii":"HI","Idaho":"ID","Illinois":"IL","Indiana":"IN","Iowa":"IA",
                    "Kansas":"KS","Kentucky":"KY","Louisiana":"LA","Maine":"ME","Maryland":"MD","Massachusetts":"MA","Michigan":"MI","Minnesota":"MN",
                    "Mississippi":"MS","Missouri":"MO","Montana":"MT","Nebraska":"NE","Nevada":"NV","New Hampshire":"NH","New Jersey":"NJ",
                    "New Mexico":"NM","New York":"NY","North Carolina":"NC","North Dakota":"ND","Ohio":"OH","Oklahoma":"OK","Oregon":"OR",
                    "Pennsylvania":"PA","Rhode Island":"RI","South Carolina":"SC","South Dakota":"SD","Tennessee":"TN","Texas":"TX","Utah":"UT",
                    "Vermont":"VT","Virginia":"VA","Washington":"WA","West Virginia":"WV","Wisconsin":"WI","Wyoming":"WY"
                };

                const normalizeCountry = (country) => {
                    if (country === "United States") return "USA";
                    return country;
                };

                const normalizeRegion = (region, country) => {
                    if (!isValid(region)) return "";
                    if (country === "United States" && stateMap[region]) return stateMap[region];
                    return region;
                };

                let maxCount = Math.max(...top5.map(c => c.visitors || c.users || 0), 1);
                let html = top5.map(c => {
                    const city = c.city;
                    const country = normalizeCountry(c.country);
                    const region = normalizeRegion(c.region, c.country);
                    const parts = [city, region, country].filter(Boolean);
                    const fullName = parts.join(", ");
                    const count = c.visitors || c.users || 0;

                    const width = Math.max(8, Math.round((count / maxCount) * 100));
                    return `<div class="dash-location-row" title="${fullName}">
                        <span class="dash-location-name">${fullName}</span>
                        <div class="dash-location-bar"><span style="width:${width}%;"></span></div>
                        <span class="dash-location-count">${count}</span>
                    </div>`;
                }).join('');
                domLocs.innerHTML = html;
            } else {
                domLocs.innerHTML = '<span style="opacity:0.5">No location data</span>';
            }

            // Geo mix (US vs International)
            const geoEl = document.getElementById('dash-visit-geo');
            if (geoEl) {
                const total = list.reduce((sum, c) => sum + (c.visitors || c.users || 0), 0) || 1;
                const usCount = list.filter(c => c.country === 'United States').reduce((sum, c) => sum + (c.visitors || c.users || 0), 0);
                const intlCount = Math.max(0, total - usCount);
                const usPct = Math.round((usCount / total) * 100);
                const intlPct = Math.max(0, 100 - usPct);
                geoEl.innerHTML = `
                    <div class="dash-geo-labels"><span>US ${usPct}%</span><span>International ${intlPct}%</span></div>
                    <div class="dash-geo-bar">
                        <span class="dash-geo-us" style="width:${usPct}%;"></span>
                        <span class="dash-geo-intl" style="width:${intlPct}%;"></span>
                    </div>
                `;
            }
            if (regionEl) {
                const countryCounts = {};
                list.forEach(c => {
                    const country = normalizeCountry(c.country);
                    const count = c.visitors || c.users || 0;
                    countryCounts[country] = (countryCounts[country] || 0) + count;
                });
                const topCountry = Object.entries(countryCounts).sort((a,b) => b[1]-a[1])[0];
                regionEl.textContent = `Top Region: ${topCountry ? topCountry[0] : 'Global'}`;
            }

            // Mini map (top 3 locations if coordinates available)
            const mapEl = document.getElementById('dash-visit-minimap');
            if (mapEl) {
                const updateMiniMapVisibility = () => {
                    const ready = mapEl._tileLoaded && mapEl._hasMarkers;
                    mapEl.classList.toggle('is-ready', !!ready);
                };

                const CITY_COORDS = {
                    'Lanzhou|China': [36.0611, 103.8343],
                    'Arlington|United States': [38.8816, -77.0910],
                    'Boardman|United States': [45.8399, -119.7011],
                    'Hanoi|Vietnam': [21.0278, 105.8342],
                    'Sulaymaniyah|Iraq': [35.5650, 45.4329],
                    'Ashburn|United States': [39.0438, -77.4874],
                    'Atlanta|United States': [33.7490, -84.3880],
                    'College Park|United States': [33.6534, -84.4494],
                    'Ha Long|Vietnam': [20.9712, 107.0448],
                    'Johns Creek|United States': [34.0289, -84.1986],
                    'Jupiter|United States': [26.9342, -80.0942],
                    'Kanawha|United States': [38.3362, -81.4807],
                    'Madrid|Spain': [40.4168, -3.7038],
                    'Manama|Bahrain': [26.2235, 50.5876],
                    'Phoenix|United States': [33.4484, -112.0740],
                    'Quito|Ecuador': [-0.1807, -78.4678]
                };

                const top3 = top5.slice(0, 3).map(c => {
                    if (typeof c.lat === 'number' && typeof c.lng === 'number') return [c.lat, c.lng, c];
                    const key = `${c.city}|${c.country}`;
                    if (CITY_COORDS[key]) return [CITY_COORDS[key][0], CITY_COORDS[key][1], c];
                    return null;
                }).filter(Boolean);

                if (top3.length === 0 || typeof L === 'undefined') {
                    mapEl._hasMarkers = false;
                    updateMiniMapVisibility();
                } else {
                    const mapInner = mapEl.querySelector('.dash-mini-map-inner') || mapEl;
                    if (!mapEl.dataset.inited) {
                        mapEl.dataset.inited = 'true';
                        const miniMap = L.map(mapInner, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false, boxZoom: false, keyboard: false, tap: false });
                        const tiles = document.body.classList.contains('dark')
                            ? L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { subdomains: 'abcd' })
                            : L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { subdomains: 'abcd' });
                        tiles.addTo(miniMap);
                        mapEl._miniMap = miniMap;
                        mapEl._tileLoaded = false;
                        tiles.on('load', () => {
                            mapEl._tileLoaded = true;
                            updateMiniMapVisibility();
                        });
                        setTimeout(() => miniMap.invalidateSize(), 200);
                    }
                    const miniMap = mapEl._miniMap;
                    if (miniMap) {
                        if (mapEl._miniMarkers) {
                            miniMap.removeLayer(mapEl._miniMarkers);
                        }
                        const group = L.featureGroup();
                        top3.forEach(([lat, lng, c]) => {
                            L.circleMarker([lat, lng], { radius: 5, color: '#e040fb', fillColor: '#e040fb', fillOpacity: 0.85, weight: 0 }).addTo(group);
                        });
                        group.addTo(miniMap);
                        mapEl._miniMarkers = group;
                        miniMap.fitBounds(group.getBounds().pad(0.4));
                        mapEl._hasMarkers = true;
                        updateMiniMapVisibility();
                    }
                }
            }
        }
    }


    // ========================================================================
    // LOGIC: METRICS & RADAR
    // ========================================================================
    function processMetrics(papers, scholarData) {
        let counts = {};
        let recentCounts = {};
        let currentYear = new Date().getFullYear();
        Object.keys(TOPIC_TAXONOMY).forEach(k => { counts[k] = 0; recentCounts[k] = 0; });

        papers.forEach(p => {
            let text = (p.title || "").toLowerCase();
            Object.keys(TOPIC_TAXONOMY).forEach(cat => {
                if(TOPIC_TAXONOMY[cat].some(k => text.includes(k.toLowerCase()))) {
                    counts[cat]++;
                    if(p.year >= currentYear - 2) recentCounts[cat]++;
                }
            });
        });

        let topSkill = Object.entries(counts).sort((a,b) => b[1]-a[1])[0];
        let trendSkill = Object.entries(recentCounts).sort((a,b) => b[1]-a[1])[0];
        updateText(IDS.METRICS.FOCUS, topSkill ? topSkill[0] : "Cybersecurity");
        updateText(IDS.METRICS.TREND, trendSkill ? trendSkill[0] : "AI");
        if(scholarData && scholarData.metrics) {
            updateText(IDS.METRICS.CITES, scholarData.metrics.citations || 0);
            updateText(IDS.METRICS.HINDEX, scholarData.metrics.hIndex || 0);
        }
    }

    
    function renderCvTopics(data) {
        const el = document.getElementById(IDS.TOPICS);
        if (!el) return;
        if (!data || !Array.isArray(data.topics)) {
            el.innerHTML = '<div style="opacity:0.6; font-size:0.7rem;">Topic model unavailable.</div>';
            return;
        }
        const topics = data.topics.slice(0, 6);
        const maxWeight = Math.max(...topics.map(t => t.weight || 0), 1);
        el.innerHTML = topics.map(topic => {
            const terms = (topic.keywords || []).slice(0, 5).join(', ');
            const pct = Math.max(8, Math.round((topic.weight / maxWeight) * 100));
            return `<div class="profile-topic-card">
                <div class="profile-topic-header">
                    <div class="profile-topic-title">${topic.label}</div>
                    <div class="profile-topic-weight">${Math.round((topic.weight || 0) * 100)}%</div>
                </div>
                <div class="profile-topic-bar"><span style="width:${pct}%"></span></div>
                <div class="profile-topic-terms">${terms}</div>
            </div>`;
        }).join('');
    }


    // ========================================================================
    // LOGIC: IMPACT MAP (UPDATED TOOLTIP)
    // ========================================================================
    function renderWorkingMap(papers) {
        var dom = document.getElementById(IDS.MAP);
        if(!dom || papers.length === 0) return;
        if(graphChart) graphChart.dispose();
        graphChart = echarts.init(dom);
        
        const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data','from','by','detection','paper','research','towards']);
        const WEIGHT_TOPIC = 1.0;
        const WEIGHT_VENUE = 2.0;
        const WEIGHT_AUTHOR = 3.0;
        const LINK_THRESHOLD = 1.5;
        const topicPalette = ['#00ff41', '#00e5ff', '#e040fb', '#ffd166', '#ff6b35', '#7c4dff', '#4dd0e1', '#80cbc4'];
        const topicColors = {};
        const topics = Object.keys(TOPIC_TAXONOMY);
        topics.forEach((t, i) => { topicColors[t] = topicPalette[i % topicPalette.length]; });
        if (!topicColors.Other) topicColors.Other = '#9e9e9e';

        let nodes = [];
        let linksRaw = [];
        let citationValues = [];

        papers.forEach((p, index) => {
            let words = (p.title||"").toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/).filter(w => w.length > 3 && !STOP_WORDS.has(w));
            p._words = new Set(words);
            p._authors = new Set();
            if(p.authors) {
                let authStr = Array.isArray(p.authors) ? p.authors.join(',') : p.authors;
                authStr.split(',').forEach(a => {
                    let clean = a.trim().toLowerCase();
                    if(!clean.includes('ampel')) p._authors.add(clean);
                });
            }
            p._venue = p.venue ? p.venue.toLowerCase().trim() : "";

            const text = (p.title || "").toLowerCase();
            let topic = 'Other';
            for (let i = 0; i < topics.length; i++) {
                const cat = topics[i];
                if (TOPIC_TAXONOMY[cat].some(k => text.includes(k.toLowerCase()))) {
                    topic = cat;
                    break;
                }
            }
            const citations = p.citations || 0;
            citationValues.push(citations);
            nodes.push({
                id: index,
                name: p.title,
                value: citations,
                year: p.year,
                authors: p.authors,
                venue: p.venue,
                topic: topic,
                yearColor: getColorByYear(p.year),
                topicColor: topicColors[topic] || topicColors.Other,
                symbolSize: Math.max(10, Math.min(65, Math.log((citations) + 2) * 9)),
                label: { show: false, formatter: p => p.name.length > 18 ? p.name.substring(0, 18) + '...' : p.name }
            });
        });

        impactState.pinned = new Set(Array.from(impactState.pinned).filter(id => id >= 0 && id < nodes.length));

        for (let i = 0; i < papers.length; i++) {
            for (let j = i + 1; j < papers.length; j++) {
                let p1 = papers[i];
                let p2 = papers[j];
                let score = 0;
                let reasons = [];
                let commonWords = 0;
                p1._words.forEach(w => { if (p2._words.has(w)) commonWords++; });
                if (commonWords > 0) { score += (commonWords * WEIGHT_TOPIC); reasons.push(`${commonWords} Keywords`); }
                if (p1._venue && p2._venue && p1._venue === p2._venue) { score += WEIGHT_VENUE; reasons.push("Same Venue"); }
                let commonAuthors = 0;
                p1._authors.forEach(a => { if (p2._authors.has(a)) commonAuthors++; });
                if (commonAuthors > 0) { score += (commonAuthors * WEIGHT_AUTHOR); reasons.push(`${commonAuthors} Co-Authors`); }

                if (score >= LINK_THRESHOLD) {
                    let avgCites = ((p1.citations || 0) + (p2.citations || 0)) / 2;
                    let impactBonus = Math.log(avgCites + 1) * 1.5;
                    linksRaw.push({
                        source: i, target: j, value: score + impactBonus, reason: reasons.join(", "),
                        types: { topic: commonWords > 0, venue: (p1._venue && p2._venue && p1._venue === p2._venue), author: commonAuthors > 0 },
                        lineStyle: { width: Math.min((score * 0.5) + impactBonus, 5), opacity: Math.min(0.15 + (score * 0.1), 0.7), curveness: 0.2 }
                    });
                }
            }
        }

        let isDark = document.body.classList.contains('dark');
        const citationThreshold = citationValues.length ? citationValues.sort((a,b) => a - b)[Math.floor(citationValues.length * 0.75)] : 0;

        const legendEl = document.getElementById('impact-map-legend');
        const inspectorEl = document.getElementById('impact-map-inspector');
        const inspectorBody = inspectorEl ? inspectorEl.querySelector('.impact-inspector-body') : null;
        const inspectorPin = inspectorEl ? inspectorEl.querySelector('[data-impact-action="pin"]') : null;
        const inspectorClear = inspectorEl ? inspectorEl.querySelector('[data-impact-action="clear"]') : null;
        const pinsEl = document.getElementById('impact-map-pins');

        function renderLegend() {
            if (!legendEl) return;
            if (impactState.colorMode === 'topic') {
                const usedTopics = Array.from(new Set(nodes.map(n => n.topic)));
                legendEl.innerHTML = usedTopics.map(t => {
                    const color = topicColors[t] || topicColors.Other;
                    return `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${color};"></span><span>${t}</span></div>`;
                }).join('');
            } else {
                legendEl.innerHTML = [
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2018)};"></span><span>2019 &amp; earlier</span></div>`,
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2021)};"></span><span>2020 - 2022</span></div>`,
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2024)};"></span><span>2023 - present</span></div>`
                ].join('');
            }
        }

        function renderPins() {
            if (!pinsEl) return;
            if (impactState.pinned.size === 0) {
                pinsEl.innerHTML = '';
                return;
            }
            pinsEl.innerHTML = Array.from(impactState.pinned).map(id => {
                const node = nodes[id];
                const label = node ? (node.name.length > 26 ? node.name.slice(0, 26) + '...' : node.name) : 'Pinned';
                return `<div class="impact-pin"><span>${label}</span><button type="button" data-pin-remove="${id}">×</button></div>`;
            }).join('');
        }

        function setInspector(node) {
            if (!inspectorBody || !inspectorPin || !inspectorClear) return;
            if (!node) {
                inspectorBody.textContent = 'Click a node to reveal context, then pin highlights you want to keep.';
                inspectorPin.disabled = true;
                inspectorClear.disabled = true;
            } else {
                inspectorBody.innerHTML = `<strong>${node.name}</strong><br>
                    <span style="opacity:0.8">Topic: ${node.topic}</span><br>
                    <span style="opacity:0.8">Venue: ${node.venue || '—'}</span><br>
                    <span style="opacity:0.8">Year: ${node.year || '—'} · Citations: ${node.value}</span>`;
                inspectorPin.disabled = false;
                inspectorClear.disabled = false;
            }
        }

        function getFilteredLinks() {
            const types = impactState.linkTypes;
            return linksRaw.filter(link => {
                return (types.topic && link.types.topic) || (types.venue && link.types.venue) || (types.author && link.types.author);
            });
        }

        function updateImpactGraph() {
            const activeLinks = getFilteredLinks();
            const neighborMap = new Map();
            activeLinks.forEach(l => {
                if (!neighborMap.has(l.source)) neighborMap.set(l.source, new Set());
                if (!neighborMap.has(l.target)) neighborMap.set(l.target, new Set());
                neighborMap.get(l.source).add(l.target);
                neighborMap.get(l.target).add(l.source);
            });

            const highlight = new Set(impactState.pinned);
            if (impactState.focusId !== null && impactState.focusId !== undefined) {
                highlight.add(impactState.focusId);
                const neighbors = neighborMap.get(impactState.focusId);
                if (neighbors) neighbors.forEach(n => highlight.add(n));
            }

            const focusActive = impactState.focusId !== null && impactState.focusId !== undefined;
            const styledNodes = nodes.map(n => {
                const isFocus = n.id === impactState.focusId;
                const isHighlight = highlight.has(n.id);
                const baseColor = impactState.colorMode === 'topic' ? n.topicColor : n.yearColor;
                const isPinned = impactState.pinned.has(n.id);
                const showLabel = isFocus || isPinned;
                return Object.assign({}, n, {
                    itemStyle: {
                        color: baseColor,
                        opacity: focusActive ? (isHighlight ? 1 : 0.08) : 1,
                        borderColor: isFocus ? '#fff' : (isPinned ? '#00e5ff' : 'transparent'),
                        borderWidth: isFocus ? 2 : (isPinned ? 1 : 0)
                    },
                    label: {
                        show: showLabel,
                        color: isDark ? '#eee' : '#222',
                        position: 'right',
                        formatter: p => p.name.length > 18 ? p.name.substring(0, 18) + '…' : p.name
                    },
                    emphasis: {
                        label: {
                            show: true,
                            color: isDark ? '#fff' : '#111',
                            fontWeight: 'bold',
                            formatter: p => p.name.length > 28 ? p.name.substring(0, 28) + '…' : p.name
                        }
                    }
                });
            });

            const styledLinks = activeLinks.map(l => {
                const linkHighlight = !focusActive || (highlight.has(l.source) && highlight.has(l.target));
                return Object.assign({}, l, {
                    lineStyle: Object.assign({}, l.lineStyle, {
                        opacity: focusActive ? (linkHighlight ? Math.min(0.65, l.lineStyle.opacity + 0.15) : 0.03) : Math.min(0.25, l.lineStyle.opacity),
                        color: isDark ? '#aaa' : '#666'
                    })
                });
            });

            graphChart.setOption({
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'item',
                    confine: true,
                    position: function (point, params, dom, rect, size) {
                        return [point[0] - (size.contentSize[0] / 2), point[1] - size.contentSize[1] - 20];
                    },
                    formatter: (p) => {
                        if (p.dataType === 'edge') {
                            return `<div style="max-width:200px; white-space:normal;"><strong>Connection</strong><br>Strength: ${Math.floor(p.value)}<br>${p.data.reason}</div>`;
                        }
                        return `<div style="max-width:260px; white-space:normal; word-wrap:break-word;">
                                    <strong>${p.name}</strong><br>
                                    <span style="opacity:0.8">Topic: ${p.data.topic}</span><br>
                                    <span style="opacity:0.8">Venue: ${p.data.venue || '—'}</span><br>
                                    <span style="opacity:0.8">Year: ${p.data.year || '—'} · Citations: ${p.value}</span>
                                </div>`;
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'force',
                    data: styledNodes,
                    links: styledLinks,
                    roam: true,
                    zoom: 0.75,
                    label: { position: 'right' },
                    lineStyle: { color: isDark ? '#aaa' : '#666' },
                    force: { repulsion: 500, gravity: 0.1, edgeLength: [50, 300] }
                }]
            }, false);
        }

        function setupImpactControls() {
            const controls = document.querySelector('.impact-map-controls');
            if (controls && !controls.dataset.bound) {
                controls.dataset.bound = 'true';
                controls.addEventListener('click', (e) => {
                    const btn = e.target.closest('button[data-impact-color]');
                    if (btn) {
                        impactState.colorMode = btn.getAttribute('data-impact-color');
                        controls.querySelectorAll('.impact-toggle').forEach(b => b.classList.toggle('is-active', b === btn));
                        renderLegend();
                        updateImpactGraph();
                    }
                });
                controls.querySelectorAll('input[data-impact-link]').forEach(input => {
                    input.addEventListener('change', () => {
                        impactState.linkTypes[input.getAttribute('data-impact-link')] = input.checked;
                        updateImpactGraph();
                    });
                });
            }

            if (inspectorEl && !inspectorEl.dataset.bound) {
                inspectorEl.dataset.bound = 'true';
                inspectorEl.addEventListener('click', (e) => {
                    const action = e.target.closest('[data-impact-action]');
                    if (action) {
                        const type = action.getAttribute('data-impact-action');
                        if (type === 'pin' && impactState.focusId !== null) {
                            impactState.pinned.add(impactState.focusId);
                            renderPins();
                            updateImpactGraph();
                        }
                        if (type === 'clear') {
                            impactState.focusId = null;
                            setInspector(null);
                            updateImpactGraph();
                        }
                    }
                    const removeBtn = e.target.closest('[data-pin-remove]');
                    if (removeBtn) {
                        const id = parseInt(removeBtn.getAttribute('data-pin-remove'), 10);
                        impactState.pinned.delete(id);
                        renderPins();
                        updateImpactGraph();
                    }
                });
            }
        }

        setupImpactControls();
        renderLegend();
        renderPins();
        setInspector(null);
        updateImpactGraph();
        graphChart.__refresh = updateImpactGraph;
        graphChart.__nodes = nodes;

        graphChart.off('click');
        graphChart.on('click', (params) => {
            if (params.dataType === 'node') {
                if (impactState.focusId === params.data.id) {
                    impactState.focusId = null;
                    setInspector(null);
                } else {
                    impactState.focusId = params.data.id;
                    setInspector(params.data);
                }
                updateImpactGraph();
            }
        });

        const btn = document.querySelector('.js-theme-toggle');
        if(btn && !btn.dataset.impactBound) {
            btn.dataset.impactBound = 'true';
            btn.addEventListener('click', () => {
                setTimeout(() => {
                    isDark = document.body.classList.contains('dark');
                    updateImpactGraph();
                }, 100);
            });
        }
    }


    // ========================================================================
    // LOGIC: COLLABORATION NETWORK
    // ========================================================================
    function renderCollabNetwork(papers) {
        var dom = document.getElementById(IDS.COLLAB);
        if(!dom) return;
        if(collabChart) collabChart.dispose();
        collabChart = echarts.init(dom);

        var myName = "Benjamin Ampel";
        var nameMap = {
            'B Ampel': 'Benjamin Ampel', 'BM Ampel': 'Benjamin Ampel', 'B. Ampel': 'Benjamin Ampel', 'admin': 'Benjamin Ampel',
            'H Chen': 'Hsinchun Chen', 'H. Chen': 'Hsinchun Chen',
            'S Samtani': 'Sagar Samtani', 'S. Samtani': 'Sagar Samtani',
            'S Ullman': 'Steven Ullman', 'S. Ullman': 'Steven Ullman',
            'H Zhu': 'Hongyi Zhu', 'H. Zhu': 'Hongyi Zhu',
            'M Patton': 'Mark Patton', 'M. Patton': 'Mark Patton',
            'B Lazarine': 'Ben Lazarine', 'B. Lazarine': 'Ben Lazarine',
            'T Vahedi': 'Tala Vahedi', 'T. Vahedi': 'Tala Vahedi',
            'K Otto': 'Kaeli Otto', 'K. Otto': 'Kaeli Otto',
            'Y Gao': 'Yang Gao', 'Y. Gao': 'Yang Gao',
            'J Hu': 'James Hu', 'J. Hu': 'James Hu',
            'CH Yang': 'Chi-Heng Yang', 'JF Nunamaker Jr': 'Jay Nunamaker',
            'C Marx': 'Carolin Marx', 'C Dacosta': 'Cade Dacosta',
            'C Zhang': 'Chengjun Zhang', 'M Hashim': 'Matthew Hashim',
            'M Wagner': 'Mason Wagner', 'RY Reyes': 'Raul Reyes',
            'S Yang': 'Shanchieh Yang', 'Y Li': 'Yidong Li', 'Y. Li': 'Yidong Li'
        };
        function normalize(name) {
            if (!name) return '';
            let clean = name.replace(/\s+/g, ' ').trim();
            if (clean.includes(',')) {
                const parts = clean.split(',').map(p => p.trim()).filter(Boolean);
                if (parts.length >= 2) clean = `${parts[1]} ${parts[0]}`;
            }
            return nameMap[clean] || clean;
        }
        collabChart.__normalize = normalize;

        const chipRow = document.querySelector('.collab-chip-row');
        if (chipRow) {
            chipRow.querySelectorAll('.collab-chip').forEach(chip => {
                chip.classList.toggle('is-active', chip.getAttribute('data-collab-range') === collabRange);
                if (!chip.dataset.bound) {
                    chip.dataset.bound = 'true';
                    chip.addEventListener('click', () => {
                        collabRange = chip.getAttribute('data-collab-range');
                        collabFocusId = null;
                        renderCollabNetwork(papers);
                    });
                }
            });
        }

        const currentYear = new Date().getFullYear();
        let filteredPapers = papers;
        if (collabRange !== 'all') {
            const yearsBack = parseInt(collabRange, 10) || 0;
            const minYear = currentYear - yearsBack + 1;
            filteredPapers = papers.filter(p => (p.year || 0) >= minYear);
        }

        var nodeCounts = new Map();
        var linkCounts = new Map();
        var authorMeta = new Map();
        var maxCount = 0;

        filteredPapers.forEach(function(paper) {
            var rawAuthors = paper.authors;
            if (!rawAuthors) return;
            var authorList = Array.isArray(rawAuthors) ? rawAuthors : rawAuthors.split(',');
            var authors = [...new Set(authorList.map(a => normalize(a.trim())).filter(a => a))];

            authors.forEach(auth => {
                let count = (nodeCounts.get(auth) || 0) + 1;
                nodeCounts.set(auth, count);
                if (auth !== myName && count > maxCount) maxCount = count;

                if (!authorMeta.has(auth)) {
                    authorMeta.set(auth, { count: 0, years: new Set(), venues: new Map(), coauthors: new Map() });
                }
                const meta = authorMeta.get(auth);
                meta.count += 1;
                if (paper.year) meta.years.add(paper.year);
                if (paper.venue) meta.venues.set(paper.venue, (meta.venues.get(paper.venue) || 0) + 1);
            });

            for (let i = 0; i < authors.length; i++) {
                for (let j = i + 1; j < authors.length; j++) {
                    let source = authors[i], target = authors[j];
                    if (source === target) continue;
                    let pairId = [source, target].sort().join("|");
                    linkCounts.set(pairId, (linkCounts.get(pairId) || 0) + 1);

                    const metaA = authorMeta.get(source);
                    const metaB = authorMeta.get(target);
                    if (metaA) metaA.coauthors.set(target, (metaA.coauthors.get(target) || 0) + 1);
                    if (metaB) metaB.coauthors.set(source, (metaB.coauthors.get(source) || 0) + 1);
                }
            }
        });

        var nodes = Array.from(nodeCounts.entries()).map(([name, count]) => {
            let isMe = (name === myName);
            return {
                id: name,
                name: name,
                value: count,
                symbolSize: isMe ? 60 : Math.max(18, Math.min(52, count * 7)),
                itemStyle: { color: isMe ? '#ffffff' : null },
                fixed: isMe,
                x: isMe ? dom.clientWidth / 2 : null,
                y: isMe ? dom.clientHeight / 2 : null
            };
        });

        const nodeIndexMap = new Map();
        nodes.forEach((n, idx) => { nodeIndexMap.set(n.name, idx); });

        var links = Array.from(linkCounts.entries()).map(([id, count]) => {
            let [source, target] = id.split("|");
            return {
                source: source, target: target, value: count,
                lineStyle: { width: Math.min(1.5 + (count * 0.8), 6), opacity: 0.6 }
            };
        });

        function getCollabColor(val, max, isDark) {
            var ratio = Math.min(Math.max((val - 1) / (max - 1 || 1), 0), 1);
            var hue = (1 - ratio) * 120;
            return isDark ? `hsl(${hue}, 90%, 60%)` : `hsl(${hue}, 80%, 40%)`;
        }

        const spotlight = document.getElementById('collab-spotlight-meta');
        const spotlightBody = document.querySelector('.collab-spotlight-body');
        const spotlightTitle = document.querySelector('.collab-spotlight-title');

        function setSpotlight(name) {
            if (!spotlight || !spotlightBody || !spotlightTitle) return;
            if (!name || !authorMeta.has(name)) {
                spotlightTitle.textContent = 'Collaborator spotlight';
                spotlightBody.textContent = 'Select a node to see their co-authorship footprint, top venues, and key connections.';
                spotlight.innerHTML = '';
                return;
            }
            const meta = authorMeta.get(name);
            const years = Array.from(meta.years).sort();
            const yearRange = years.length ? `${years[0]} - ${years[years.length - 1]}` : '—';
            const topVenues = Array.from(meta.venues.entries()).sort((a,b) => b[1]-a[1]).slice(0, 3).map(v => v[0]).join(', ') || '—';
            const topCoauthors = Array.from(meta.coauthors.entries()).sort((a,b) => b[1]-a[1]).slice(0, 3).map(c => `${c[0]} (${c[1]})`).join(', ') || '—';

            spotlightTitle.textContent = name;
            spotlightBody.textContent = `${meta.count} co-authored papers`;
            spotlight.innerHTML = `
                <div class="collab-meta-row"><span>Active years</span><strong>${yearRange}</strong></div>
                <div class="collab-meta-row"><span>Top venues</span><strong>${topVenues}</strong></div>
                <div class="collab-meta-row"><span>Key co-authors</span><strong>${topCoauthors}</strong></div>
            `;
        }

        function updateCollabGraph() {
            const neighborMap = new Map();
            links.forEach(l => {
                if (!neighborMap.has(l.source)) neighborMap.set(l.source, new Set());
                if (!neighborMap.has(l.target)) neighborMap.set(l.target, new Set());
                neighborMap.get(l.source).add(l.target);
                neighborMap.get(l.target).add(l.source);
            });

            const highlight = new Set();
            if (collabFocusId) {
                highlight.add(collabFocusId);
                const neighbors = neighborMap.get(collabFocusId);
                if (neighbors) neighbors.forEach(n => highlight.add(n));
            }

            let isDark = document.body.classList.contains('dark');
            const styledNodes = nodes.map(n => {
                const isFocus = collabFocusId === n.id;
                const isHighlight = highlight.size === 0 || highlight.has(n.id);
                const baseColor = n.id === myName ? (isDark ? '#fff' : '#000') : getCollabColor(n.value, maxCount, isDark);
                return Object.assign({}, n, {
                    itemStyle: {
                        color: baseColor,
                        opacity: highlight.size === 0 ? 1 : (isHighlight ? 1 : 0.08),
                        borderColor: isFocus ? '#00e5ff' : (n.id === myName ? (isDark ? '#000' : '#fff') : 'transparent'),
                        borderWidth: isFocus ? 2 : (n.id === myName ? 2 : 0)
                    },
                    label: { show: n.value > 1 || n.id === myName || isHighlight, color: isDark?'#eee':'#333' }
                });
            });

            const styledLinks = links.map(l => {
                const linkHighlight = highlight.size === 0 || (highlight.has(l.source) && highlight.has(l.target));
                return Object.assign({}, l, {
                    lineStyle: Object.assign({}, l.lineStyle, {
                        opacity: highlight.size === 0 ? l.lineStyle.opacity : (linkHighlight ? Math.min(0.8, l.lineStyle.opacity + 0.2) : 0.05),
                        color: getCollabColor(l.value, maxCount, isDark)
                    })
                });
            });

            collabChart.setOption({
                backgroundColor: 'transparent',
                tooltip: { formatter: p => p.dataType==='edge' ? `${p.data.source} & ${p.data.target}<br>${p.value} Papers` : `${p.name}: ${p.value} Papers` },
                series: [{
                    type: 'graph', layout: 'force', data: styledNodes, links: styledLinks, roam: true, zoom: 0.6,
                    label: { position: 'right' },
                    lineStyle: { curveness: 0.2 },
                    force: { repulsion: 800, gravity: 0.1, edgeLength: [30, 150] }
                }]
            }, false);
        }

        if (collabFocusId && !nodeCounts.has(collabFocusId)) {
            collabFocusId = null;
        }

        setSpotlight(collabFocusId);
        updateCollabGraph();
        collabChart.__refresh = updateCollabGraph;
        collabChart.__indexMap = nodeIndexMap;

        collabChart.off('click');
        collabChart.on('click', (params) => {
            if (params.dataType === 'node') {
                if (collabFocusId === params.data.id) {
                    collabFocusId = null;
                    setSpotlight(null);
                } else {
                    collabFocusId = params.data.id;
                    setSpotlight(collabFocusId);
                }
                updateCollabGraph();
            }
        });

        const btn = document.querySelector('.js-theme-toggle');
        if(btn && !btn.dataset.collabBound) {
            btn.dataset.collabBound = 'true';
            btn.addEventListener('click', () => { setTimeout(() => { updateCollabGraph(); }, 100); });
        }
    }


    // ========================================================================
    // LOGIC: FOOTPRINT MAP
    // ========================================================================
    function renderFootprintMap() {
        var container = document.getElementById(IDS.FOOTPRINT);
        if(!container) return;
        
        var map = L.map(IDS.FOOTPRINT).setView([30, -20], 2);
        footprintMap = map;

        var lightTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 18 });
        var darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 18 });

        if (document.body.classList.contains('dark')) { darkTiles.addTo(map); } else { lightTiles.addTo(map); }

        var points = [
            {{ range $.Site.Data.impact_map }}
            { "title": "{{ .title }}", "lat": {{ .lat }}, "lng": {{ .lng }}, "location": "{{ .location }}", "desc": "{{ .description }}", "cat": "{{ .category }}" },
            {{ end }}
        ];

        const categoryColors = {
            Conference: '#00ff41',
            Collaboration: '#00bfff',
            Institution: '#ff6b35'
        };

        function extractYears(text) {
            if (!text) return [];
            const matches = text.match(/(19|20)\d{2}/g) || [];
            return matches.map(v => parseInt(v, 10)).filter(y => y > 1900 && y < 2100);
        }

        const enrichedPoints = points.map(p => {
            const years = [...new Set([...extractYears(p.title), ...extractYears(p.desc)])].sort();
            const minYear = years.length ? years[0] : null;
            const maxYear = years.length ? years[years.length - 1] : null;
            return Object.assign({}, p, { years: years, minYear: minYear, maxYear: maxYear });
        });

        const yearValues = enrichedPoints.filter(p => p.minYear).map(p => p.maxYear || p.minYear);
        const minYear = yearValues.length ? Math.min(...yearValues) : (new Date().getFullYear() - 6);
        const maxYear = yearValues.length ? Math.max(...yearValues) : new Date().getFullYear();

        const state = {
            categories: { Conference: true, Collaboration: true, Institution: true },
            layers: { routes: true, heat: true, clusters: true },
            year: maxYear
        };

        const legendEl = document.getElementById('footprint-legend');
        if (legendEl) {
            legendEl.innerHTML = Object.keys(categoryColors).map(cat => (
                `<div class="legend-row"><span class="footprint-legend-dot" style="--legend-color:${categoryColors[cat]};"></span><span>${cat}</span></div>`
            )).join('');
        }

        const rangeEl = document.getElementById('footprint-year-range');
        const labelEl = document.getElementById('footprint-year-label');
        if (rangeEl && labelEl) {
            rangeEl.min = minYear;
            rangeEl.max = maxYear;
            rangeEl.value = maxYear;
            labelEl.textContent = `Up to ${maxYear}`;
            rangeEl.addEventListener('input', () => {
                state.year = parseInt(rangeEl.value, 10);
                labelEl.textContent = `Up to ${state.year}`;
                applyFilters();
            });
        }

        function createIcon(category) {
            const cls = category.toLowerCase();
            return L.divIcon({
                className: '',
                html: `<div class="footprint-marker ${cls}"><span class="ring"></span><span class="dot"></span></div>`,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        const markerLayer = L.layerGroup();
        const arcLayer = L.layerGroup().addTo(map);
        const clusterLayer = (L.markerClusterGroup ? L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 50 }) : null);
        const heatLayer = (L.heatLayer ? L.heatLayer([], { radius: 26, blur: 18, maxZoom: 4, minOpacity: 0.12, gradient: { 0.0: 'rgba(0,0,0,0)', 0.4: '#00bfff', 0.7: '#00ff41', 1.0: '#e040fb' } }) : null);

        function withinYear(point) {
            if (!point.minYear) return true;
            return point.minYear <= state.year;
        }

        function buildMarkers(list) {
            markerLayer.clearLayers();
            if (clusterLayer) clusterLayer.clearLayers();
            list.forEach(point => {
                const icon = createIcon(point.cat || 'Collaboration');
                const popup = `<div><strong>${point.title}</strong><br><span style="font-size:0.8em">${point.location}</span><br><span style="font-size:0.8em;opacity:0.7">${point.cat}</span></div>`;
                const marker = L.marker([point.lat, point.lng], { icon: icon }).bindPopup(popup);
                if (state.layers.clusters && clusterLayer) {
                    clusterLayer.addLayer(marker);
                } else {
                    markerLayer.addLayer(marker);
                }
            });

            if (state.layers.clusters && clusterLayer) {
                if (!map.hasLayer(clusterLayer)) map.addLayer(clusterLayer);
                if (map.hasLayer(markerLayer)) map.removeLayer(markerLayer);
            } else {
                if (!map.hasLayer(markerLayer)) map.addLayer(markerLayer);
                if (clusterLayer && map.hasLayer(clusterLayer)) map.removeLayer(clusterLayer);
            }
        }

        function createArc(latlng1, latlng2) {
            const lat1 = latlng1.lat, lng1 = latlng1.lng;
            const lat2 = latlng2.lat, lng2 = latlng2.lng;
            const midLat = (lat1 + lat2) / 2;
            const midLng = (lng1 + lng2) / 2;
            const dx = lng2 - lng1;
            const dy = lat2 - lat1;
            const norm = Math.sqrt(dx * dx + dy * dy) || 1;
            const offset = Math.min(12, norm * 0.25);
            const ctrlLat = midLat + (-dx / norm) * offset;
            const ctrlLng = midLng + (dy / norm) * offset;
            const coords = [];
            for (let t = 0; t <= 1.001; t += 0.06) {
                const lat = (1 - t) * (1 - t) * lat1 + 2 * (1 - t) * t * ctrlLat + t * t * lat2;
                const lng = (1 - t) * (1 - t) * lng1 + 2 * (1 - t) * t * ctrlLng + t * t * lng2;
                coords.push([lat, lng]);
            }
            return coords;
        }

        function buildArcs(list) {
            arcLayer.clearLayers();
            if (!state.layers.routes) return;
            const routePoints = list
                .filter(p => p.minYear)
                .filter(p => p.cat === 'Conference' || p.cat === 'Institution')
                .sort((a, b) => (a.minYear || 9999) - (b.minYear || 9999));

            for (let i = 0; i < routePoints.length - 1; i++) {
                const start = routePoints[i];
                const end = routePoints[i + 1];
                const arc = L.polyline(createArc({ lat: start.lat, lng: start.lng }, { lat: end.lat, lng: end.lng }), { className: 'footprint-arc' });
                arcLayer.addLayer(arc);
            }
        }

        function buildHeat(list) {
            if (!heatLayer) return;
            if (!state.layers.heat) {
                if (map.hasLayer(heatLayer)) map.removeLayer(heatLayer);
                return;
            }
            const weights = { Conference: 0.8, Institution: 0.9, Collaboration: 0.6 };
            const heatPoints = list.map(p => [p.lat, p.lng, weights[p.cat] || 0.5]);
            heatLayer.setLatLngs(heatPoints);
            if (!map.hasLayer(heatLayer)) heatLayer.addTo(map);
        }

        function applyFilters() {
            const filtered = enrichedPoints.filter(p => state.categories[p.cat] && withinYear(p));
            buildMarkers(filtered);
            buildArcs(filtered);
            buildHeat(filtered);
        }

        document.querySelectorAll('input[data-footprint-cat]').forEach(input => {
            input.addEventListener('change', () => {
                const cat = input.getAttribute('data-footprint-cat');
                state.categories[cat] = input.checked;
                applyFilters();
            });
        });

        document.querySelectorAll('input[data-footprint-layer]').forEach(input => {
            input.addEventListener('change', () => {
                const layer = input.getAttribute('data-footprint-layer');
                state.layers[layer] = input.checked;
                applyFilters();
            });
        });

        applyFilters();

        const observer = new MutationObserver((mutations) => {
            mutations.forEach((m) => {
                if (m.attributeName === 'class') {
                    if (document.body.classList.contains('dark')) { map.removeLayer(lightTiles); if(!map.hasLayer(darkTiles)) darkTiles.addTo(map); }
                    else { map.removeLayer(darkTiles); if(!map.hasLayer(lightTiles)) lightTiles.addTo(map); }
                }
            });
        });
        observer.observe(document.body, { attributes: true });
        
        setTimeout(() => map.invalidateSize(), 500);
        window.addEventListener('resize', () => map.invalidateSize());
    }


    // --- HELPERS (Line, Text) ---
    function renderLine(history) {
        var dom = document.getElementById(IDS.LINE);
        if(!dom || !history) return;
        if(lineChart) lineChart.dispose();
        lineChart = echarts.init(dom);
        let isDark = document.body.classList.contains('dark');
        lineChart.setOption({
            tooltip: { trigger: 'axis', formatter: '{b}: {c} Citations' },
            grid: { top: 10, right: 10, bottom: 20, left: 30, containLabel: true },
            xAxis: { type: 'category', data: history.map(d => d.year), axisLine: { show: false }, axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } },
            yAxis: { type: 'value', splitLine: { show: false }, axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } },
            series: [{ type: 'bar', data: history.map(d => d.citations), itemStyle: { color: isDark ? '#00e5ff' : '#1a0dab', borderRadius: [2,2,0,0] }, barWidth: '40%' }]
        });
    }

    function calculateAllMetrics(papers) {
        let n = papers.length;
        const currentYear = new Date().getFullYear();
        if (n === 0) return;
        let adj = Array.from({length: n}, () => []);
        let degrees = new Array(n).fill(0);
        let topicLinks = new Array(n).fill(0);
        let venueLinks = new Array(n).fill(0);
        let authorLinks = new Array(n).fill(0);

        const normalizeAuthor = (name) => name.toLowerCase().replace(/\s+/g, ' ').trim();
        const authorSets = papers.map(p => {
            if (!p.authors) return new Set();
            let list = Array.isArray(p.authors) ? p.authors : p.authors.split(',');
            return new Set(list.map(a => normalizeAuthor(a)).filter(Boolean));
        });

        const wordSets = papers.map(p => {
            let text = (p.title || "").toLowerCase().replace(/[^a-z0-9 ]/g, ' ');
            return new Set(text.split(/\s+/).filter(w => w.length > 4));
        });

        const getWeight = (i, j) => {
            let p1 = papers[i], p2 = papers[j];
            let w = 0;
            if(p1.venue === p2.venue && p1.venue) { w += 1; venueLinks[i] += 1; venueLinks[j] += 1; }
            let commonWords = 0;
            wordSets[i].forEach(word => { if(wordSets[j].has(word)) commonWords++; });
            if(commonWords > 0) { w += commonWords * 0.5; topicLinks[i] += commonWords; topicLinks[j] += commonWords; }
            let commonAuthors = 0;
            authorSets[i].forEach(a => { if(authorSets[j].has(a)) commonAuthors++; });
            if(commonAuthors > 0) { authorLinks[i] += commonAuthors; authorLinks[j] += commonAuthors; }
            return w;
        };

        for(let i=0; i<n; i++) {
            for(let j=i+1; j<n; j++) {
                let weight = getWeight(i, j);
                if(weight > 0.5) { adj[i].push(j); adj[j].push(i); degrees[i]++; degrees[j]++; }
            }
        }

        const computeEigen = (indices) => {
            const mapIndex = new Map();
            indices.forEach((idx, i) => mapIndex.set(idx, i));
            const size = indices.length;
            let subAdj = Array.from({length: size}, () => []);
            indices.forEach((idx, i) => {
                adj[idx].forEach(nbr => {
                    if (mapIndex.has(nbr)) subAdj[i].push(mapIndex.get(nbr));
                });
            });
            let scores = new Array(size).fill(1.0);
            for(let iter=0; iter<10; iter++) {
                let nextScores = new Array(size).fill(0);
                for(let i=0; i<size; i++) { for(let neighbor of subAdj[i]) { nextScores[i] += scores[neighbor]; } }
                let maxS = Math.max(...nextScores) || 1;
                scores = nextScores.map(s => s / maxS);
            }
            const result = new Array(n).fill(0);
            indices.forEach((idx, i) => { result[idx] = scores[i] || 0; });
            return result;
        };

        let eigenScores = computeEigen([...Array(n).keys()]);

        let betweenness = new Array(n).fill(0);
        for(let s=0; s<n; s++) {
            let q = [s], preds = Array.from({length: n}, () => []), levels = new Array(n).fill(-1); levels[s] = 0;
            while(q.length > 0) {
                let v = q.shift();
                for(let w of adj[v]) {
                    if(levels[w] === -1) { levels[w] = levels[v] + 1; q.push(w); }
                    if(levels[w] === levels[v] + 1) { preds[w].push(v); }
                }
            }
            for(let i=0; i<n; i++) { if(i !== s && levels[i] > 0) { for(let p of preds[i]) betweenness[p] += 1; } }
        }

        const edgeCount = degrees.reduce((sum, d) => sum + d, 0) / 2;
        const density = n > 1 ? (2 * edgeCount) / (n * (n - 1)) : 0;

        const pathStats = (() => {
            let totalDist = 0;
            let totalPairs = 0;
            for (let i = 0; i < n; i++) {
                let dist = new Array(n).fill(-1);
                dist[i] = 0;
                let queue = [i];
                while (queue.length) {
                    const v = queue.shift();
                    adj[v].forEach(w => {
                        if (dist[w] === -1) { dist[w] = dist[v] + 1; queue.push(w); }
                    });
                }
                for (let j = i + 1; j < n; j++) {
                    if (dist[j] > 0) { totalDist += dist[j]; totalPairs += 1; }
                }
            }
            return { avgPath: totalPairs ? (totalDist / totalPairs) : 0 };
        })();

        const clusteringCoeff = (() => {
            let total = 0;
            let count = 0;
            const adjSet = adj.map(list => new Set(list));
            for (let i = 0; i < n; i++) {
                const neighbors = adj[i];
                const k = neighbors.length;
                if (k < 2) continue;
                let links = 0;
                for (let a = 0; a < k; a++) {
                    for (let b = a + 1; b < k; b++) {
                        if (adjSet[neighbors[a]].has(neighbors[b])) links++;
                    }
                }
                total += (2 * links) / (k * (k - 1));
                count++;
            }
            return count ? total / count : 0;
        })();

        const centralityInfo = papers.map((p, i) => ({
            index: i,
            title: p.title,
            year: p.year,
            venue: p.venue,
            citations: p.citations || 0,
            eigen: eigenScores[i],
            between: betweenness[i],
            degree: degrees[i],
            topicLinks: topicLinks[i],
            venueLinks: venueLinks[i],
            authorLinks: authorLinks[i],
            authors: Array.isArray(p.authors) ? p.authors : (p.authors ? p.authors.split(',').map(a => a.trim()) : [])
        }));

        const percentile = (arr, p) => {
            const sorted = arr.slice().sort((a,b) => a - b);
            if (!sorted.length) return 0;
            const idx = Math.floor((sorted.length - 1) * p);
            return sorted[idx];
        };

        const topicThresh = percentile(topicLinks, 0.75);
        const venueThresh = percentile(venueLinks, 0.75);
        const authorThresh = percentile(authorLinks, 0.75);
        const citeThresh = percentile(centralityInfo.map(c => c.citations || 0), 0.75);

        const sparklineValues = (paper) => {
            const cites = paper.citations || 0;
            const year = paper.year || currentYear;
            const age = Math.max(1, currentYear - year + 1);
            const steps = 6;
            let vals = [];
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const scaled = cites * Math.pow(t, 1.4);
                vals.push(Math.max(0, scaled));
            }
            if (vals.every(v => v === 0)) {
                vals = [0,0,0,0,0,0];
            }
            return vals;
        };

        const sparklineSvg = (values) => {
            const w = 90, h = 26;
            const max = Math.max(...values, 1);
            const pts = values.map((v, i) => {
                const x = 2 + (i / (values.length - 1)) * (w - 4);
                const y = h - 3 - (v / max) * (h - 8);
                return `${x},${y}`;
            }).join(' ');
            return `<svg class="centrality-sparkline" viewBox="0 0 ${w} ${h}" role="img" aria-label="Estimated citation growth"><polyline points="${pts}" fill="none" stroke="#00e5ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        };

        const renderCentralityList = (mode) => {
            const scores = {
                eigen: { key: 'eigen', color: '#00ff41', label: 'Influence' },
                between: { key: 'between', color: '#00e5ff', label: 'Bridges' },
                degree: { key: 'degree', color: '#e040fb', label: 'Hubs' }
            }[mode];

            const ranked = centralityInfo.slice().sort((a,b) => b[scores.key] - a[scores.key]).slice(0, 6);
            const maxScore = Math.max(...ranked.map(r => r[scores.key]), 1);

            const listEl = document.getElementById('centrality-list');
            if (!listEl) return;
            listEl.innerHTML = ranked.map((r, idx) => {
                const pills = [];
                if (r.topicLinks >= topicThresh) pills.push('Topic hub');
                if (r.venueLinks >= venueThresh) pills.push('Venue anchor');
                if (r.authorLinks >= authorThresh) pills.push('Co-author dense');
                if (r.citations >= citeThresh) pills.push('High impact');
                if (mode === 'between') pills.unshift('Cross-cluster');
                const pillHtml = pills.slice(0, 3).map(p => `<span class="centrality-pill">${p}</span>`).join('');
                const scorePct = Math.min(100, Math.round((r[scores.key] / maxScore) * 100));
                const badge = idx < 3 ? `<span class="centrality-badge">Top ${idx + 1}</span>` : '';
                return `<div class="centrality-item" data-paper-index="${r.index}" tabindex="0" role="button">
                    <div class="centrality-bar" style="width:${scorePct}%;"></div>
                    <div class="centrality-item-header">
                        <div class="centrality-rank">#${idx + 1}</div>
                        <div class="centrality-main">
                            <div class="centrality-title">${r.title}</div>
                            <div class="centrality-meta">${r.year || '—'} · ${r.venue || '—'}</div>
                            <div class="centrality-pills">${pillHtml}</div>
                        </div>
                        <div class="centrality-sidebits">
                            <div class="centrality-badges">${badge}</div>
                            ${sparklineSvg(sparklineValues(r))}
                        </div>
                    </div>
                </div>`;
            }).join('');

            listEl.querySelectorAll('.centrality-item').forEach(item => {
                item.addEventListener('mouseenter', () => highlightPaper(parseInt(item.getAttribute('data-paper-index'), 10)));
                item.addEventListener('mouseleave', () => clearHighlight());
                item.addEventListener('focusin', () => highlightPaper(parseInt(item.getAttribute('data-paper-index'), 10)));
                item.addEventListener('focusout', () => clearHighlight());
            });

            setCohesionRadar(ranked[0]);
        };

        const updateMetricCard = (id, value, suffix) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = suffix ? `${value}${suffix}` : value;
        };

        updateMetricCard('centrality-density', density.toFixed(2));
        updateMetricCard('centrality-path', pathStats.avgPath ? pathStats.avgPath.toFixed(2) : '—');
        updateMetricCard('centrality-cluster', clusteringCoeff ? clusteringCoeff.toFixed(2) : '—');

        const radarEl = document.getElementById('centrality-radar');
        if (radarEl) {
            if (centralityRadarChart) centralityRadarChart.dispose();
            centralityRadarChart = echarts.init(radarEl);
        }

        const maxTopic = Math.max(...topicLinks, 1);
        const maxVenue = Math.max(...venueLinks, 1);
        const maxAuthor = Math.max(...authorLinks, 1);

        const setCohesionRadar = (paper) => {
            if (!paper || !centralityRadarChart) return;
            const values = [
                Math.round((paper.topicLinks / maxTopic) * 10),
                Math.round((paper.venueLinks / maxVenue) * 10),
                Math.round((paper.authorLinks / maxAuthor) * 10)
            ];
            const noteEl = document.getElementById('centrality-note');
            if (noteEl) {
                noteEl.textContent = `${paper.title}`;
            }
            centralityRadarChart.setOption({
                tooltip: { show: false },
                radar: {
                    indicator: [
                        { name: 'Topic', max: 10 },
                        { name: 'Venue', max: 10 },
                        { name: 'Co-author', max: 10 }
                    ],
                    splitNumber: 4,
                    axisName: { color: '#bde8ff', fontSize: 10 },
                    splitLine: { lineStyle: { color: 'rgba(0,229,255,0.2)' } },
                    axisLine: { lineStyle: { color: 'rgba(0,229,255,0.3)' } },
                    splitArea: { show: false }
                },
                series: [{
                    type: 'radar',
                    data: [{ value: values, areaStyle: { color: 'rgba(0,229,255,0.25)' }, lineStyle: { color: '#00e5ff', width: 2 } }]
                }]
            });
        };

        const highlightPaper = (index) => {
            if (!Number.isFinite(index)) return;
            const paper = papers[index];
            if (graphChart) {
                graphChart.dispatchAction({ type: 'downplay', seriesIndex: 0 });
                graphChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: index });
            }
            if (collabChart) {
                collabChart.dispatchAction({ type: 'downplay', seriesIndex: 0 });
                const names = Array.isArray(paper.authors) ? paper.authors : (paper.authors ? paper.authors.split(',') : []);
                const indexMap = collabChart.__indexMap || new Map();
                const normalize = collabChart.__normalize;
                names.forEach(name => {
                    const key = normalize ? normalize(name) : name.trim();
                    if (indexMap.has(key)) {
                        collabChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: indexMap.get(key) });
                    }
                });
            }
            const info = centralityInfo.find(c => c.index === index);
            if (info) setCohesionRadar(info);
        };

        const clearHighlight = () => {
            if (graphChart && graphChart.__refresh) {
                graphChart.dispatchAction({ type: 'downplay', seriesIndex: 0 });
                graphChart.__refresh();
            }
            if (collabChart && collabChart.__refresh) {
                collabChart.dispatchAction({ type: 'downplay', seriesIndex: 0 });
                collabChart.__refresh();
            }
        };

        const tabs = document.querySelectorAll('.centrality-tab');
        tabs.forEach(tab => {
            if (!tab.dataset.bound) {
                tab.dataset.bound = 'true';
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('is-active'));
                    tab.classList.add('is-active');
                    renderCentralityList(tab.getAttribute('data-centrality-tab'));
                });
            }
        });

        renderCentralityList('eigen');
    }

    function getColorByYear(year) {
        let y = parseInt(year) || 2022;
        if (y < 2020) return '#e040fb';
        if (y < 2023) return '#00e5ff';
        return '#00ff41';
    }

    function updateText(id, val) { var el = document.getElementById(id); if(el) el.innerText = val; }

    window.addEventListener('resize', function() {
        if(lineChart) lineChart.resize();
        if(graphChart) graphChart.resize();
        if(collabChart) collabChart.resize();
        if(visitTrendChart) visitTrendChart.resize();
        if(visitDeviceChart) visitDeviceChart.resize();
        if(centralityRadarChart) centralityRadarChart.resize();
        if(footprintMap) footprintMap.invalidateSize();
    });

    function refreshDashboardLayout() {
        if(radarChart) radarChart.resize();
        if(lineChart) lineChart.resize();
        if(graphChart) graphChart.resize();
        if(collabChart) collabChart.resize();
        if(visitTrendChart) visitTrendChart.resize();
        if(visitDeviceChart) visitDeviceChart.resize();
        if(centralityRadarChart) centralityRadarChart.resize();
        if(footprintMap) footprintMap.invalidateSize();
        const miniMapContainer = document.getElementById('dash-visit-minimap');
        if (miniMapContainer && miniMapContainer._miniMap) {
            miniMapContainer._miniMap.invalidateSize();
        }
    }

    const dashboardWrapper = document.getElementById('dashboard-wrapper');
    const dashboardDetails = dashboardWrapper ? dashboardWrapper.closest('details') : null;
    if (dashboardDetails) {
        dashboardDetails.addEventListener('toggle', () => {
            if (dashboardDetails.open) {
                setTimeout(refreshDashboardLayout, 200);
            }
        });
        if (dashboardDetails.open) {
            setTimeout(refreshDashboardLayout, 200);
        }
    }

})();
</script>
