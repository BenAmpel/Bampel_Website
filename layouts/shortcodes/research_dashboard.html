<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

<div id="dashboard-wrapper" style="min-height:550px; margin:30px 0; font-family:sans-serif;">
<div style="display:grid; grid-template-columns:1fr 1fr; grid-template-rows:auto 600px; gap:0; border:1px solid var(--card-border, #333); border-radius:12px; overflow:hidden; background:var(--card-bg, rgba(255,255,255,0.02)); box-shadow:0 4px 20px rgba(0,0,0,0.1);">

<div style="grid-column:1; grid-row:1; padding:20px; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333);">
<h4 style="margin:0 0 10px; opacity:0.7; text-align:center; text-transform:uppercase; font-size:0.8rem;">Research Profile</h4>
<div id="dashboard-radar" style="width:100%; height:300px;"></div>
</div>

<div style="grid-column:2; grid-row:1; padding:25px; border-bottom:1px solid var(--card-border, #333); display:flex; flex-direction:column;">
<div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
<div><div style="font-size:0.75rem; opacity:0.6;">Primary Focus</div><div id="dash-metric-focus" style="font-size:1rem; font-weight:800; color:#00ff41; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
<div><div style="font-size:0.75rem; opacity:0.6;">Trending</div><div id="dash-metric-trend" style="font-size:1rem; font-weight:800; color:#00e5ff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
<div><div style="font-size:0.75rem; opacity:0.6;">Total Citations</div><div id="dash-metric-cites" style="font-size:1.4rem; font-weight:800; color:#e040fb;">0</div></div>
<div><div style="font-size:0.75rem; opacity:0.6;">h-index</div><div id="dash-metric-hindex" style="font-size:1.4rem; font-weight:800; opacity:0.9;">0</div></div>
</div>
<div style="flex-grow:1; border-top:1px solid var(--card-border, #333); padding-top:15px; position:relative;">
<h4 style="margin:0 0 5px; font-size:0.7rem; opacity:0.5; text-transform:uppercase;">Citation Velocity</h4>
<div id="dashboard-timeline" style="width:100%; height:160px;"></div>
</div>
</div>

<div style="grid-column:1; grid-row:2; padding:0; border-right:1px solid var(--card-border, #333); position:relative; height:100%;">
<div style="position:absolute; top:20px; left:20px; z-index:10; pointer-events:none;">
<h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase;">Impact Map</h4>
<p style="margin:0; font-size:0.65rem; opacity:0.5;">Connections by Topic, Venue & Co-authors</p>
</div>
<div id="dashboard-impact-map" style="width:100%; height:100%;"></div>
</div>

<div style="grid-column:2; grid-row:2; padding:25px; display:flex; flex-direction:column; height:100%;">
<h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin-bottom:15px;">Most Central Papers</h4>
<p style="font-size:0.7rem; opacity:0.5; margin-top:-10px; margin-bottom:15px;">Eigenvector Centrality (Network Influence)</p>
<div id="dashboard-centrality-list" style="font-size:0.8rem; line-height:1.5; overflow-y:auto; max-height:400px;">
<span style="opacity:0.5;">Calculating network influence...</span>
</div>
</div>

</div>
</div>

<script type="text/javascript">
(function() {
    // 1. IDS configuration
    const IDS = {
        RADAR: 'dashboard-radar',
        LINE: 'dashboard-timeline',
        MAP: 'dashboard-impact-map', // RENAMED to avoid conflict
        CENTRALITY: 'dashboard-centrality-list',
        METRICS: {
            FOCUS: 'dash-metric-focus', TREND: 'dash-metric-trend',
            CITES: 'dash-metric-cites', HINDEX: 'dash-metric-hindex'
        }
    };

    var radarChart, lineChart, graphChart;

    // 2. FETCH DATA
    const safeFetch = (url) => fetch(url).then(r => r.ok ? r.json() : null).catch(e => null);

    Promise.all([
        safeFetch('/data/publications.json'),
        safeFetch('/data/scholar-metrics.json')
    ]).then(([papersData, scholarData]) => {
        
        let papers = [];
        // Prioritize scholar-metrics.json (It contains the citation data needed for the working graph)
        if (scholarData && scholarData.individualPublications) {
            papers = scholarData.individualPublications;
        } else if (papersData) {
            papers = Array.isArray(papersData) ? papersData : (papersData.individualPublications || []);
        }

        // --- A. METRICS & TAXONOMY (Existing Dashboard Logic) ---
        const taxonomy = {
            'AI / Deep Learning': ['Deep Learning', 'Neural', 'Transfer Learning', 'Embedding', 'Machine Learning', 'Artificial Intelligence', 'Adversarial'],
            'Cybersecurity':      ['Cyber', 'Vulnerability', 'Exploit', 'Attack', 'Threat', 'Security', 'Malicious', 'Ransomware', 'Phishing'],
            'LLMs & NLP':         ['Large Language Model', 'LLM', 'Text Analytics', 'NLP', 'Transformer', 'Bert', 'GPT', 'Language Models'],
            'Hacker Communities': ['Hacker', 'Forum', 'Dark Web', 'Paste', 'Community', 'Marketplace', 'Underground'],
            'Design Science':     ['Design Science', 'Framework', 'Artifact', 'System', 'Implementation', 'Prototyping'],
            'Behavioral':         ['Nudging', 'Bias', 'Social', 'Human', 'Behavior', 'Psychology', 'Decision', 'Trust']
        };

        let counts = {};
        let recentCounts = {};
        let currentYear = new Date().getFullYear();
        Object.keys(taxonomy).forEach(k => { counts[k] = 0; recentCounts[k] = 0; });

        papers.forEach(p => {
            let text = (p.title || "").toLowerCase();
            Object.keys(taxonomy).forEach(cat => {
                if(taxonomy[cat].some(k => text.includes(k.toLowerCase()))) {
                    counts[cat]++;
                    if(p.year >= currentYear - 2) recentCounts[cat]++;
                }
            });
        });

        // Update Metrics UI
        let topSkill = Object.entries(counts).sort((a,b) => b[1]-a[1])[0];
        let trendSkill = Object.entries(recentCounts).sort((a,b) => b[1]-a[1])[0];
        
        updateText(IDS.METRICS.FOCUS, topSkill ? topSkill[0] : "Cybersecurity");
        updateText(IDS.METRICS.TREND, trendSkill ? trendSkill[0] : "AI");
        
        if(scholarData && scholarData.metrics) {
            updateText(IDS.METRICS.CITES, scholarData.metrics.citations || 0);
            updateText(IDS.METRICS.HINDEX, scholarData.metrics.hIndex || 0);
        }

        // --- B. RENDER CHARTS ---
        renderRadar(counts);
        if(scholarData && scholarData.citationsByYear) renderLine(scholarData.citationsByYear);
        
        // --- C. RENDER WORKING MAP ---
        // Calling the specific function that uses logic from knowledge_graph.html
        renderWorkingMap(papers); 
        
        calculateCentrality(papers);

    }).catch(err => console.error("Dashboard Error:", err));


    // --- 3. THE "WORKING" MAP RENDERER ---
    // Logic ported directly from knowledge_graph.html
    function renderWorkingMap(papers) {
        var dom = document.getElementById(IDS.MAP);
        if(!dom || papers.length === 0) return;
        
        if(graphChart) graphChart.dispose();
        graphChart = echarts.init(dom);
        
        // CONFIG FROM knowledge_graph.html
        const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data','from','by','detection','paper','research','towards']);
        const WEIGHT_TOPIC = 1.0;
        const WEIGHT_VENUE = 2.0;
        const WEIGHT_AUTHOR = 3.0;
        const LINK_THRESHOLD = 1.5;

        let nodes = [];
        let links = [];

        // 1. Pre-process Nodes
        papers.forEach((p, index) => {
            // Keywords
            let words = (p.title||"").toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/)
                .filter(w => w.length > 3 && !STOP_WORDS.has(w));
            p._words = new Set(words);

            // Authors
            p._authors = new Set();
            if(p.authors) {
                let authStr = Array.isArray(p.authors) ? p.authors.join(',') : p.authors;
                authStr.split(',').forEach(a => {
                    let clean = a.trim().toLowerCase();
                    if(!clean.includes('ampel')) p._authors.add(clean);
                });
            }

            // Venue
            p._venue = p.venue ? p.venue.toLowerCase().trim() : "";

            nodes.push({
                id: index,
                name: p.title,
                value: p.citations || 0,
                year: p.year,
                authors: p.authors,
                venue: p.venue,
                // EXACT Sizing Logic from knowledge_graph.html
                symbolSize: Math.max(10, Math.min(65, Math.log((p.citations || 0) + 2) * 9)),
                itemStyle: { color: getColorByYear(p.year) },
                label: {
                    show: (p.citations || 0) > 15,
                    formatter: function(params) {
                        return params.name.length > 15 ? params.name.substring(0, 15) + '...' : params.name;
                    }
                }
            });
        });

        // 2. Generate Links (Nested Loop from knowledge_graph.html)
        for (let i = 0; i < papers.length; i++) {
            for (let j = i + 1; j < papers.length; j++) {
                let p1 = papers[i];
                let p2 = papers[j];
                let score = 0;
                let reasons = [];

                // Topic
                let commonWords = 0;
                p1._words.forEach(w => { if (p2._words.has(w)) commonWords++; });
                if (commonWords > 0) {
                    score += (commonWords * WEIGHT_TOPIC);
                    reasons.push(`${commonWords} Keywords`);
                }

                // Venue
                if (p1._venue && p2._venue && p1._venue === p2._venue) {
                    score += WEIGHT_VENUE;
                    reasons.push("Same Venue");
                }

                // Authors
                let commonAuthors = 0;
                p1._authors.forEach(a => { if (p2._authors.has(a)) commonAuthors++; });
                if (commonAuthors > 0) {
                    score += (commonAuthors * WEIGHT_AUTHOR);
                    reasons.push(`${commonAuthors} Co-Authors`);
                }

                if (score >= LINK_THRESHOLD) {
                    let avgCites = ((p1.citations || 0) + (p2.citations || 0)) / 2;
                    let impactBonus = Math.log(avgCites + 1) * 1.5;

                    links.push({
                        source: i,
                        target: j,
                        value: score + impactBonus,
                        reason: reasons.join(", "),
                        lineStyle: {
                            width: Math.min((score * 0.5) + impactBonus, 5),
                            opacity: Math.min(0.15 + (score * 0.1), 0.7),
                            curveness: 0.2
                        }
                    });
                }
            }
        }

        // 3. Render Chart (Options from knowledge_graph.html)
        let isDark = document.body.classList.contains('dark');
        let option = {
            backgroundColor: 'transparent',
            tooltip: {
                formatter: (params) => {
                    if (params.dataType === 'edge') {
                        return `<strong>Connection Strength:</strong> ${Math.floor(params.value)}<br>Link: ${params.data.reason}`;
                    }
                    return `<strong>${params.name}</strong><br>
                            Year: ${params.data.year}<br>
                            Citations: ${params.value}<br>
                            <span style="font-size:0.8em; opacity:0.8">${params.data.venue || ''}</span>`;
                }
            },
            series: [{
                type: 'graph',
                layout: 'force',
                data: nodes,
                links: links,
                roam: true,
                zoom: 0.75,
                label: { position: 'right', color: 'inherit' },
                lineStyle: { color: isDark ? '#aaa' : '#666' },
                force: {
                    initLayout: 'circular',
                    repulsion: 500,
                    gravity: 0.1,
                    edgeLength: [50, 300],
                    friction: 0.9
                }
            }]
        };

        graphChart.setOption(option);
        
        // Theme Toggle Listener
        const btn = document.querySelector('.js-theme-toggle');
        if(btn) {
            btn.addEventListener('click', () => {
                setTimeout(() => {
                    let isDarkNow = document.body.classList.contains('dark');
                    graphChart.setOption({
                        series: [{ lineStyle: { color: isDarkNow ? '#aaa' : '#666' } }]
                    });
                }, 100);
            });
        }
    }

    // Color Logic from knowledge_graph.html
    function getColorByYear(year) {
        let y = parseInt(year) || 2022;
        if (y < 2020) return '#e040fb'; // Purple
        if (y < 2023) return '#00e5ff'; // Cyan
        return '#00ff41';               // Green
    }

    // --- OTHER HELPERS ---

    function calculateCentrality(papers) {
        let scores = new Array(papers.length).fill(1.0);
        const iterations = 10;
        for(let iter=0; iter<iterations; iter++) {
            let nextScores = new Array(papers.length).fill(0);
            for(let i=0; i<papers.length; i++) {
                for(let j=0; j<papers.length; j++) {
                    if(i === j) continue;
                    let p1 = papers[i], p2 = papers[j];
                    let weight = 0;
                    if(p1.venue === p2.venue && p1.venue) weight += 1;
                    nextScores[i] += scores[j] * (weight + 0.1); 
                }
            }
            let maxS = Math.max(...nextScores) || 1;
            scores = nextScores.map(s => s / maxS);
        }
        let ranked = papers.map((p, i) => ({ 
            title: p.title, 
            score: scores[i] + (Math.log((p.citations||0)+1)*0.5)
        })).sort((a,b) => b.score - a.score).slice(0, 3);

        let html = ranked.map((r, i) => {
            let color = ['#00ff41', '#00e5ff', '#e040fb'][i];
            return `<div style="display:flex; gap:10px; margin-bottom:10px; align-items:start;">
                <div style="font-weight:bold; color:${color}; font-size:1.1em;">#${i+1}</div>
                <div style="font-size:0.85em; line-height:1.3;">${r.title}</div>
            </div>`;
        }).join('');
        
        let el = document.getElementById(IDS.CENTRALITY);
        if(el) el.innerHTML = html;
    }

    function renderRadar(counts) {
        var dom = document.getElementById(IDS.RADAR);
        if(!dom) return;
        if(radarChart) radarChart.dispose();
        radarChart = echarts.init(dom);
        
        let data = Object.keys(counts).map(k => ({ name: k, value: counts[k] }));
        let max = Math.max(...data.map(item => item.value)) || 1;
        let isDark = document.body.classList.contains('dark');
        
        radarChart.setOption({
            radar: {
                indicator: data.map(item => ({ name: item.name, max: max + 2 })),
                shape: 'circle',
                splitArea: { show: false },
                axisName: { color: isDark ? '#aaa' : '#333' }
            },
            series: [{
                type: 'radar',
                data: [{
                    value: data.map(item => item.value),
                    itemStyle: { color: isDark ? '#00ff41' : '#d93025' },
                    areaStyle: { opacity: 0.2 }
                }]
            }]
        });
    }

    function renderLine(history) {
        var dom = document.getElementById(IDS.LINE);
        if(!dom || !history) return;
        if(lineChart) lineChart.dispose();
        lineChart = echarts.init(dom);
        let isDark = document.body.classList.contains('dark');

        lineChart.setOption({
            grid: { top: 10, right: 10, bottom: 20, left: 30, containLabel: true },
            xAxis: { 
                type: 'category', 
                data: history.map(item => item.year),
                axisLine: { show: false }, 
                axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } 
            },
            yAxis: { 
                type: 'value', 
                splitLine: { show: false }, 
                axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } 
            },
            series: [{
                type: 'bar',
                data: history.map(item => item.citations),
                itemStyle: { color: isDark ? '#00e5ff' : '#1a0dab', borderRadius: [2,2,0,0] },
                barWidth: '40%'
            }]
        });
    }

    function updateText(id, val) {
        var el = document.getElementById(id);
        if(el) el.innerText = val;
    }

    window.addEventListener('resize', function() {
        if(radarChart) radarChart.resize();
        if(lineChart) lineChart.resize();
        if(graphChart) graphChart.resize();
    });

})();
</script>
