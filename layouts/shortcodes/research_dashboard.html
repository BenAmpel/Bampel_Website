{{/* Research Command Center - With Network Centrality Analysis */}}
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

<div id="dashboard-root" style="min-height: 550px; margin: 30px 0;"></div>

<script type="text/javascript">
(function() {
    var root = document.getElementById('dashboard-root');
    var radarChart, lineChart, knowledgeGraphChart;
    var storedPublications = null; // Store for theme toggle re-rendering
    var storedScholarData = null; // Store full scholarData for theme toggle
    var storedHistory = null;

    // --- 1. LAYOUT GENERATOR ---
    function renderLayout() {
        var isDark = document.body.classList.contains('dark');
        var bg = isDark ? 'rgba(255,255,255,0.02)' : '#ffffff';
        var border = isDark ? '#333' : '#eee';
        var muted = isDark ? '#888' : '#666';
        var text = isDark ? '#aaa' : '#333';
        var highlight = isDark ? '#00e5ff' : '#1a0dab';
        var shadow = isDark ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.05)';

        // Colors for metrics
        var c1 = isDark ? '#00ff41' : '#d93025'; 
        var c2 = isDark ? '#00e5ff' : '#1a0dab'; 
        var c3 = isDark ? '#e040fb' : '#9c27b0'; 

        return `
        <div id="research-card" style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 0; background: ${bg}; border: 1px solid ${border}; border-radius: 12px; box-shadow: 0 4px 20px ${shadow}; overflow: hidden; min-height: 600px;">
            
            <div style="grid-column: 1; grid-row: 1; padding: 20px; display: flex; flex-direction: column; border-right: 1px solid ${border}; border-bottom: 1px solid ${border};">
                <h4 style="margin: 0 0 10px; font-size: 0.9rem; color: ${muted}; text-transform: uppercase; letter-spacing: 1px; text-align: center;">Research Profile</h4>
                <div id="dash-radar" style="width: 100%; height: 100%; min-height: 250px;"></div>
            </div>

            <div style="grid-column: 2; grid-row: 1; padding: 25px; border-bottom: 1px solid ${border}; display: flex; flex-direction: column;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div><div style="font-size: 0.8rem; color: ${muted};">Primary Focus</div><div style="font-size: 1.1rem; font-weight: 800; color: ${c1};" id="metric-focus">...</div></div>
                    <div><div style="font-size: 0.8rem; color: ${muted};">Trending</div><div style="font-size: 1.1rem; font-weight: 800; color: ${c2};" id="metric-trend">...</div></div>
                    <div><div style="font-size: 0.8rem; color: ${muted};">Velocity</div><div style="font-size: 1.1rem; font-weight: 800; color: ${c2};" id="metric-velocity">-</div></div>
                    <div><div style="font-size: 0.8rem; color: ${muted};">Total Citations</div><div style="font-size: 1.5rem; font-weight: 800; color: ${c3};" id="metric-cites">0</div></div>
                    <div><div style="font-size: 0.8rem; color: ${muted};">h-index</div><div style="font-size: 1.5rem; font-weight: 800; color: ${text};" id="metric-hindex">0</div></div>
                </div>
                <div style="flex-grow: 1; border-top: 1px solid ${border}; padding-top: 15px;">
                    <div id="dash-line" style="width: 100%; height: 180px;"></div>
                </div>
            </div>

            <div style="grid-column: 1; grid-row: 2; padding: 20px; border-right: 1px solid ${border};">
                <h4 style="margin: 0 0 10px; font-size: 0.9rem; color: ${muted}; text-transform: uppercase;">Impact Map</h4>
                <div id="knowledge-graph" style="width: 100%; height: 90%;"></div>
            </div>

            <div style="grid-column: 2; grid-row: 2; padding: 25px; display: flex; flex-direction: column;">
                <h4 style="font-size: 0.8rem; color: ${muted}; text-transform: uppercase; margin-bottom: 15px;">Collaboration DNA</h4>
                
                <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                    <div style="flex: 1; background: ${isDark ? 'rgba(255,255,255,0.05)' : '#f8f9fa'}; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: ${muted}; text-transform: uppercase;">Density</div>
                        <div style="font-size: 1.4rem; font-weight: 800; color: ${text};" id="net-density">0.00</div>
                        <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 5px;">Network interconnection</div>
                    </div>
                    <div style="flex: 1; background: ${isDark ? 'rgba(255,255,255,0.05)' : '#f8f9fa'}; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: ${muted}; text-transform: uppercase;">Network Cohesion</div>
                        <div style="font-size: 1.4rem; font-weight: 800; color: ${highlight};" id="net-lcc">0%</div>
                        <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 5px;">Largest component size</div>
                    </div>
                </div>

                <div>
                    <div style="font-size: 0.75rem; color: ${muted}; text-transform: uppercase; margin-bottom: 8px;">Primary Research Clusters</div>
                    <div id="net-clusters" style="font-size: 0.85rem; line-height: 1.6;">
                        <span style="opacity: 0.5;">Analyzing co-authorship communities...</span>
                    </div>
                </div>
            </div>
        </div>`;
    }

    // --- 2. INIT LAYOUT ---
    root.innerHTML = renderLayout();
    radarChart = echarts.init(document.getElementById('dash-radar'));
    lineChart = echarts.init(document.getElementById('dash-line'));
    knowledgeGraphChart = echarts.init(document.getElementById('knowledge-graph'));

    // --- 3. SAFE FETCH HELPER ---
    const safeFetch = (url) => fetch(url)
        .then(response => {
            if (!response.ok) {
                console.warn(`File not found (${response.status}): ${url}`);
                return null; // Return null instead of crashing
            }
            return response.json().then(data => {
                console.log(`Successfully loaded: ${url}`, data);
                return data;
            }).catch(err => {
                console.warn(`JSON parse error for ${url}:`, err);
                return null;
            });
        })
        .catch(err => {
            console.warn(`Network error loading ${url}:`, err);
            return null;
        });

    // --- 4. FETCH DATA ---
    Promise.all([
        safeFetch('/data/publications.json'),
        safeFetch('/data/scholar-metrics.json'),
        safeFetch('/data/network_stats.json')
    ]).then(([papersData, scholarData, netStats]) => {
        
        // Handle "Publications" which might be a list or an object
        let papers = [];
        if (papersData) {
            papers = Array.isArray(papersData) ? papersData : (papersData.individualPublications || []);
        }

        // If major data is missing, stop here
        if (!scholarData && papers.length === 0) {
            console.error("No data available to render dashboard.");
            return;
        }

        // A. Get Inferred Interests from JSON (or fallback to default)
        let inferredInterests = [];
        if (scholarData && scholarData.metrics && scholarData.metrics.interests && scholarData.metrics.interests.length > 0) {
            inferredInterests = scholarData.metrics.interests;
        } else {
            // Fallback to default categories if not available
            inferredInterests = ['AI', 'Cybersecurity', 'Blockchain', 'Deep Learning', 'Design Science', 'Dark Web'];
        }

        // B. Calculate frequency counts for inferred interests
        let counts = {};
        let recentCounts = {};
        let currentYear = new Date().getFullYear();
        inferredInterests.forEach(interest => {
            counts[interest] = 0;
            recentCounts[interest] = 0;
        });

        if(Array.isArray(papers) && papers.length > 0) {
            papers.forEach(p => {
                let text = (p.title || "").toLowerCase();
                inferredInterests.forEach(interest => {
                    if(text.includes(interest.toLowerCase())) {
                        counts[interest]++;
                        if(p.year >= currentYear - 2) recentCounts[interest]++;
                    }
                });
            });
        }

        // C. Populate Text Metrics (use first two inferred interests as fallback)
        let topSkill = Object.entries(counts).sort((a,b) => b[1]-a[1])[0];
        let trendSkill = Object.entries(recentCounts).sort((a,b) => b[1]-a[1])[0];
        updateText('metric-focus', topSkill && topSkill[1] > 0 ? topSkill[0] : (inferredInterests[0] || "Cybersecurity"));
        updateText('metric-trend', trendSkill && trendSkill[1] > 0 ? trendSkill[0] : (inferredInterests[1] || "AI"));

        // D. Metrics (Top Right)
        if (scholarData && scholarData.metrics) {
            let rawCites = String(scholarData.metrics.citations || 0);
            let cleanCites = parseInt(rawCites.replace(/\D/g, '')) || 0;
            let suffix = rawCites.includes('+') ? '+' : '';
            animateValue("metric-cites", 0, cleanCites, 2000, suffix);
            updateText('metric-hindex', scholarData.metrics.hIndex || 0);
            
            // Citation Velocity
            let velocity = 0;
            if (scholarData.metrics.citationVelocity !== undefined && scholarData.metrics.citationVelocity !== null) {
                velocity = scholarData.metrics.citationVelocity;
            } else if (scholarData.citationsByYear && scholarData.citationsByYear.length > 0) {
                // Fallback: calculate from most recent year
                let recentYear = scholarData.citationsByYear[scholarData.citationsByYear.length - 1];
                velocity = recentYear.citations || 0;
            }
            updateText('metric-velocity', velocity);
        }

        // E. Render Charts
        storedScholarData = scholarData; // Store for theme toggle
        storedHistory = scholarData ? scholarData.citationsByYear : null; // Store for theme toggle
        if (scholarData) {
            renderRadar(scholarData); // Pass full scholarData to use inferred interests
        }
        if (scholarData && scholarData.citationsByYear) {
            renderLine(scholarData.citationsByYear);
        }

        // F. Render Network Stats (Bottom Right)
        console.log('Network stats received:', netStats, 'Type:', typeof netStats);
        if (netStats && typeof netStats === 'object' && !Array.isArray(netStats)) {
            // Update density and LCC
            var densityVal = netStats.density !== undefined && netStats.density !== null 
                ? (typeof netStats.density === 'number' ? netStats.density.toFixed(2) : String(netStats.density))
                : "0.00";
            updateText('net-density', densityVal);
            
            var lccVal = netStats.lcc_percentage !== undefined && netStats.lcc_percentage !== null
                ? (netStats.lcc_percentage + "%")
                : "0%";
            updateText('net-lcc', lccVal);
            
            // Render clusters
            var clustersEl = document.getElementById('net-clusters');
            if (clustersEl) {
                if (netStats.clusters && Array.isArray(netStats.clusters) && netStats.clusters.length > 0) {
                    let html = '';
                    netStats.clusters.forEach((c, i) => {
                        let members = c.top_members && Array.isArray(c.top_members) ? c.top_members.slice(0, 3).join(", ") : "";
                        let color = ['#00ff41', '#00e5ff', '#e040fb'][i] || '#ccc';
                        html += `
                        <div style="margin-bottom: 8px; padding-left: 10px; border-left: 3px solid ${color};">
                            <strong style="color: inherit; opacity: 0.9;">Group ${String.fromCharCode(65+i)}</strong> 
                            <span style="opacity: 0.6; font-size: 0.8em;">(${c.size || 0} people)</span><br>
                            <span style="font-size: 0.75em; opacity: 0.7;">w/ ${members || "N/A"}</span>
                        </div>`;
                    });
                    clustersEl.innerHTML = html;
                } else {
                    clustersEl.innerHTML = '<span style="opacity:0.5; font-size:0.8em">No clusters identified</span>';
                }
            }
        } else {
            // Fallback if file is missing or invalid
            console.warn('Network stats not available. Value:', netStats, 'Type:', typeof netStats);
            var clustersEl = document.getElementById('net-clusters');
            if (clustersEl) {
                clustersEl.innerHTML = '<span style="opacity:0.5; font-size:0.8em">Analysis pending...</span>';
            }
        }

        // G. CALCULATE CENTRALITY & KNOWLEDGE GRAPH
        if(scholarData && scholarData.individualPublications) {
            storedPublications = scholarData.individualPublications; // Store for theme toggle
            calculateCentrality(scholarData.individualPublications);
            renderKnowledgeGraph(scholarData.individualPublications);
        } else if (papers.length > 0) {
            // Fallback: use papers from publications.json if available
            storedPublications = papers;
            renderKnowledgeGraph(papers);
        }

    }).catch(e => console.error("Critical Dashboard Failure:", e));

    // Helper to safely update text
    function updateText(id, val) {
        const el = document.getElementById(id);
        if (el) el.innerText = val;
    }


    // --- 4. CENTRALITY ALGORITHM ---
    function calculateCentrality(pubs) {
        // Config
        const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data']);
        
        // 1. Build Adjacency Matrix (Graph)
        let n = pubs.length;
        if(n === 0) return;
        
        let nodes = pubs.map((p, i) => ({ 
            id: i, 
            title: p.title, 
            words: new Set(p.title.toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/).filter(w => w.length > 3 && !STOP_WORDS.has(w))),
            authors: new Set((p.authors || "").split(',').map(a => a.trim().toLowerCase())),
            venue: (p.venue || "").toLowerCase().trim(),
            score: 1.0 // Initial score
        }));

        let adj = Array(n).fill().map(() => []); // Adjacency list

        for(let i=0; i<n; i++) {
            for(let j=i+1; j<n; j++) {
                let weight = 0;
                
                // Topic Match
                nodes[i].words.forEach(w => { if(nodes[j].words.has(w)) weight += 1; });
                // Venue Match
                if(nodes[i].venue && nodes[j].venue && nodes[i].venue === nodes[j].venue) weight += 2;
                // Author Match
                nodes[i].authors.forEach(a => { if(nodes[j].authors.has(a) && !a.includes('ampel')) weight += 3; });

                if(weight > 0) {
                    adj[i].push({ target: j, weight: weight });
                    adj[j].push({ target: i, weight: weight });
                }
            }
        }

        // 2. Eigenvector Centrality (Power Iteration)
        // Repeat 20 times (Converges quickly for small graphs)
        for(let iter=0; iter<20; iter++) {
            let newScores = new Float32Array(n);
            let maxScore = 0;

            for(let i=0; i<n; i++) {
                let sum = 0;
                // Sum of neighbors' scores weighted by connection strength
                adj[i].forEach(edge => {
                    sum += nodes[edge.target].score * edge.weight;
                });
                newScores[i] = sum;
                if(sum > maxScore) maxScore = sum;
            }

            // Normalize to prevent overflow
            if(maxScore > 0) {
                for(let i=0; i<n; i++) {
                    nodes[i].score = newScores[i] / maxScore;
                }
            }
        }

        // 3. Sort & Display
        nodes.sort((a,b) => b.score - a.score);
        
        let html = '';
        nodes.slice(0, 3).forEach((node, idx) => {
            let color = document.body.classList.contains('dark') ? '#00e5ff' : '#1a0dab';
            html += `
            <div style="display:flex; gap:10px; margin-bottom:8px; align-items:center;">
                <div style="font-weight:bold; color:${color}; font-size:1.1em;">#${idx+1}</div>
                <div style="line-height:1.2; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical;">
                    ${node.title}
                </div>
            </div>`;
        });
        document.getElementById('centrality-list').innerHTML = html;
    }

    // --- 5. KNOWLEDGE GRAPH RENDERER ---
    function renderKnowledgeGraph(papers) {
        const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data','from','by','detection','paper','research','towards']);
        
        // Weight Tuning
        const WEIGHT_TOPIC = 1.0;
        const WEIGHT_VENUE = 2.0;
        const WEIGHT_AUTHOR = 3.0;
        const LINK_THRESHOLD = 1.5;
        
        let nodes = [];
        let links = [];

        // 1. Pre-process Nodes
        papers.forEach((p, index) => {
            let words = (p.title || "").toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/)
                .filter(w => w.length > 3 && !STOP_WORDS.has(w));
            p._words = new Set(words);

            p._authors = new Set();
            if(p.authors) {
                p.authors.split(',').forEach(a => {
                    let clean = a.trim().toLowerCase();
                    if(!clean.includes('ampel')) p._authors.add(clean);
                });
            }

            p._venue = p.venue ? p.venue.toLowerCase().trim() : "";

            nodes.push({
                id: index,
                name: p.title,
                value: p.citations || 0,
                year: p.year,
                authors: p.authors,
                venue: p.venue,
                symbolSize: Math.max(10, Math.min(65, Math.log((p.citations || 0) + 2) * 9)),
                itemStyle: { color: getColorByYear(p.year) },
                label: {
                    show: (p.citations || 0) > 15,
                    formatter: function(params) {
                        return params.name.length > 15 ? params.name.substring(0, 15) + '...' : params.name;
                    }
                }
            });
        });

        // 2. Generate Links
        for (let i = 0; i < papers.length; i++) {
            for (let j = i + 1; j < papers.length; j++) {
                let p1 = papers[i];
                let p2 = papers[j];
                let score = 0;
                let reasons = [];

                let commonWords = 0;
                p1._words.forEach(w => { if (p2._words.has(w)) commonWords++; });
                if (commonWords > 0) {
                    score += (commonWords * WEIGHT_TOPIC);
                    reasons.push(`${commonWords} Keywords`);
                }

                if (p1._venue && p2._venue && p1._venue === p2._venue) {
                    score += WEIGHT_VENUE;
                    reasons.push("Same Venue");
                }

                let commonAuthors = 0;
                p1._authors.forEach(a => { if (p2._authors.has(a)) commonAuthors++; });
                if (commonAuthors > 0) {
                    score += (commonAuthors * WEIGHT_AUTHOR);
                    reasons.push(`${commonAuthors} Co-Authors`);
                }

                if (score >= LINK_THRESHOLD) {
                    let avgCites = ((p1.citations || 0) + (p2.citations || 0)) / 2;
                    let impactBonus = Math.log(avgCites + 1) * 1.5;

                    links.push({
                        source: i,
                        target: j,
                        value: score + impactBonus,
                        reason: reasons.join(", "),
                        lineStyle: {
                            width: Math.min((score * 0.5) + impactBonus, 5),
                            opacity: Math.min(0.15 + (score * 0.1), 0.7),
                            curveness: 0.2
                        }
                    });
                }
            }
        }

        let isDark = document.body.classList.contains('dark');
        let option = {
            backgroundColor: 'transparent',
            tooltip: {
                formatter: (params) => {
                    if (params.dataType === 'edge') {
                        return `<strong>Connection Strength:</strong> ${Math.floor(params.value)}<br>Link: ${params.data.reason}`;
                    }
                    return `<strong>${params.name}</strong><br>
                            Year: ${params.data.year}<br>
                            Citations: ${params.value}<br>
                            <span style="font-size:0.8em; opacity:0.8">${params.data.venue || ''}</span>`;
                }
            },
            series: [{
                type: 'graph',
                layout: 'force',
                data: nodes,
                links: links,
                roam: true,
                zoom: 0.75,
                label: { position: 'right', color: 'inherit' },
                lineStyle: { color: isDark ? '#aaa' : '#666' },
                force: {
                    initLayout: 'circular',
                    repulsion: 500,
                    gravity: 0.1,
                    edgeLength: [50, 300],
                    friction: 0.9
                }
            }]
        };

        knowledgeGraphChart.setOption(option);
        
        const btn = document.querySelector('.js-theme-toggle');
        if(btn) {
            btn.addEventListener('click', () => {
                setTimeout(() => {
                    let isDarkNow = document.body.classList.contains('dark');
                    knowledgeGraphChart.setOption({
                        series: [{ lineStyle: { color: isDarkNow ? '#aaa' : '#666' } }]
                    });
                }, 100);
            });
        }
        window.addEventListener('resize', () => knowledgeGraphChart.resize());
    }

    function getColorByYear(year) {
        let y = parseInt(year) || 2022;
        if (y < 2020) return '#e040fb';
        if (y < 2023) return '#00e5ff';
        return '#00ff41';
    }

    // --- HELPERS ---
    function renderRadar(data) {
        // 1. Get Inferred Interests from JSON
        var categories = (data.metrics && data.metrics.interests && data.metrics.interests.length > 0) 
            ? data.metrics.interests 
            : ['AI', 'Cybersecurity', 'Blockchain', 'Deep Learning', 'Design Science', 'Dark Web'];

        // 2. Calculate Frequency (Count matching papers)
        var papers = data.individualPublications || [];
        var seriesData = categories.map(cat => {
            var count = papers.filter(p => p.title && p.title.toLowerCase().includes(cat.toLowerCase())).length;
            return count > 0 ? count : 1; // Minimum 1 for visibility
        });

        // 3. Render Chart
        let max = Math.max(...seriesData) || 1;
        let chartData = categories.map((cat, idx) => ({
            name: cat, max: 100, 
            value: Math.min(Math.round((seriesData[idx]/max)*90)+10, 100)
        }));

        function getOpt(isDark) {
            let c = isDark ? '#00ff41' : '#d93025';
            let txt = isDark ? '#eee' : '#333';
            return {
                radar: {
                    indicator: chartData.map(d => ({ name: d.name, max: 100 })),
                    shape: 'circle', radius: '65%',
                    axisName: { color: txt, fontSize: 10, fontWeight: 'bold' },
                    splitLine: { lineStyle: { color: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' } },
                    splitArea: { show: false }
                },
                series: [{
                    type: 'radar',
                    data: [{
                        value: chartData.map(d => d.value),
                        itemStyle: { color: c },
                        lineStyle: { width: 2, color: c },
                        areaStyle: { color: new echarts.graphic.RadialGradient(0.5, 0.5, 1, [{offset:0, color: c+'10'}, {offset:1, color: c+'60'}]) }
                    }]
                }]
            };
        }
        updateChart(radarChart, getOpt);
    }

    function renderLine(history) {
        if(!history || !Array.isArray(history)) return;
        let years = history.map(d => d.year);
        let vals = history.map(d => d.citations);

        function getOpt(isDark) {
            let c = isDark ? '#00e5ff' : '#1a0dab';
            let txt = isDark ? '#888' : '#666';
            return {
                grid: { top: 10, right: 10, bottom: 20, left: 30, containLabel: true },
                tooltip: { trigger: 'axis' },
                xAxis: { type: 'category', data: years, axisLine: {show:false}, axisTick: {show:false}, axisLabel: {color: txt, fontSize: 9} },
                yAxis: { type: 'value', splitLine: { show: false }, axisLabel: {color: txt, fontSize: 9} },
                series: [{
                    data: vals, type: 'bar', barWidth: '40%',
                    itemStyle: { color: c, borderRadius: [2,2,0,0] },
                    animationDuration: 2000
                }]
            };
        }
        updateChart(lineChart, getOpt);
    }

    function updateChart(chart, getOptFunc) {
        let isDark = document.body.classList.contains('dark');
        chart.setOption(getOptFunc(isDark));
        const btn = document.querySelector('.js-theme-toggle');
        if(btn) {
            btn.addEventListener('click', () => {
                setTimeout(() => {
                   let isDarkNow = document.body.classList.contains('dark');
                   chart.setOption(getOptFunc(isDarkNow));
                   var cites = document.getElementById('metric-cites').innerText;
                   var hidx = document.getElementById('metric-hindex').innerText;
                   var focus = document.getElementById('metric-focus').innerText;
                   var trend = document.getElementById('metric-trend').innerText;
                   var velocity = document.getElementById('metric-velocity') ? document.getElementById('metric-velocity').innerText : '-';
                   root.innerHTML = renderLayout(); 
                   document.getElementById('metric-cites').innerText = cites;
                   document.getElementById('metric-hindex').innerText = hidx;
                   document.getElementById('metric-focus').innerText = focus;
                   document.getElementById('metric-trend').innerText = trend;
                   if (document.getElementById('metric-velocity')) {
                       document.getElementById('metric-velocity').innerText = velocity;
                   }
                   // Reinitialize charts
                   radarChart = echarts.init(document.getElementById('dash-radar'));
                   lineChart = echarts.init(document.getElementById('dash-line'));
                   knowledgeGraphChart = echarts.init(document.getElementById('knowledge-graph'));
                   // Re-render charts with new theme
                   if(storedCounts) {
                       if (storedScholarData) {
                           renderRadar(storedScholarData);
                       }
                   }
                   if(storedHistory) {
                       renderLine(storedHistory);
                   }
                   if(storedPublications) {
                       calculateCentrality(storedPublications);
                       renderKnowledgeGraph(storedPublications);
                   } 
                }, 100);
            });
        }
        window.addEventListener('resize', () => chart.resize());
    }

    function animateValue(id, start, end, duration, suffix) {
        let obj = document.getElementById(id);
        if(!obj) return;
        let startTimestamp = null;
        const step = (ts) => {
            if (!startTimestamp) startTimestamp = ts;
            const progress = Math.min((ts - startTimestamp) / duration, 1);
            let current = Math.floor(progress * (end - start) + start);
            obj.innerHTML = current + (suffix || "");
            if (progress < 1) window.requestAnimationFrame(step);
        };
        window.requestAnimationFrame(step);
    }
})();
</script>
