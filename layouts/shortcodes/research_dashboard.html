<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

<div id="dashboard-wrapper" style="min-height:1300px; margin:30px 0; font-family:sans-serif;">
<div style="display:grid; grid-template-columns:1fr 1fr; grid-template-rows:auto 600px 600px 300px; gap:0; border:1px solid var(--card-border, #333); border-radius:12px; overflow:hidden; background:var(--card-bg, rgba(255,255,255,0.02)); box-shadow:0 4px 20px rgba(0,0,0,0.1);">

<div style="grid-column:1; grid-row:1; padding:20px; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333);">
    <h4 style="margin:0 0 10px; opacity:0.7; text-align:center; text-transform:uppercase; font-size:0.8rem;">Research Profile</h4>
    <div id="dashboard-radar" style="width:100%; height:300px;"></div>
</div>

<div style="grid-column:2; grid-row:1; padding:25px; border-bottom:1px solid var(--card-border, #333); display:flex; flex-direction:column;">
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
        <div><div style="font-size:0.75rem; opacity:0.6;">Primary Focus</div><div id="dash-metric-focus" style="font-size:1rem; font-weight:800; color:#00ff41; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">Emerging Focus</div><div id="dash-metric-trend" style="font-size:1rem; font-weight:800; color:#00e5ff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">...</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">Total Citations</div><div id="dash-metric-cites" style="font-size:1.4rem; font-weight:800; color:#e040fb;">0</div></div>
        <div><div style="font-size:0.75rem; opacity:0.6;">h-index</div><div id="dash-metric-hindex" style="font-size:1.4rem; font-weight:800; opacity:0.9;">0</div></div>
    </div>
    <div style="flex-grow:1; border-top:1px solid var(--card-border, #333); padding-top:15px; position:relative;">
        <h4 style="margin:0 0 5px; font-size:0.7rem; opacity:0.5; text-transform:uppercase;">Citation Velocity</h4>
        <div id="dashboard-timeline" style="width:100%; height:160px;"></div>
    </div>
</div>

<div style="grid-column:1; grid-row:2; padding:0; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; left:20px; z-index:10; pointer-events:none;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase;">Impact Map</h4>
        <p style="margin:0; font-size:0.65rem; opacity:0.5;">Connections by Topic, Venue & Co-authors</p>
    </div>
    <div class="impact-map-controls" aria-label="Impact map controls">
        <div class="impact-control-group" role="group" aria-label="Color mode">
            <button class="impact-toggle is-active" data-impact-color="topic" type="button">Color: Topic</button>
            <button class="impact-toggle" data-impact-color="year" type="button">Color: Year</button>
        </div>
        <div class="impact-control-group" role="group" aria-label="Connection types">
            <label class="impact-check"><input type="checkbox" data-impact-link="topic" checked> Topics</label>
            <label class="impact-check"><input type="checkbox" data-impact-link="venue" checked> Venues</label>
            <label class="impact-check"><input type="checkbox" data-impact-link="author" checked> Co-authors</label>
        </div>
    </div>
    <div class="impact-map-legend" id="impact-map-legend"></div>
    <div class="impact-map-inspector" id="impact-map-inspector" aria-live="polite">
        <div class="impact-inspector-title">Focus lens</div>
        <div class="impact-inspector-body">Click a node to reveal context, then pin highlights you want to keep.</div>
        <div class="impact-inspector-actions">
            <button class="impact-action" type="button" data-impact-action="pin" disabled>Pin highlight</button>
            <button class="impact-action" type="button" data-impact-action="clear" disabled>Clear focus</button>
        </div>
        <div class="impact-inspector-pins" id="impact-map-pins"></div>
    </div>
    <div id="dashboard-impact-map" style="width:100%; height:100%;"></div>
</div>

<div style="grid-column:2; grid-row:2; padding:25px; border-bottom:1px solid var(--card-border, #333); display:flex; flex-direction:column; height:100%; overflow:hidden;">
    <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin-bottom:15px; border-bottom:1px solid var(--card-border, #444); padding-bottom:10px;">Network Centrality Analysis</h4>
    <div style="overflow-y:auto; padding-right:5px; flex-grow:1;">
        <div style="margin-bottom:20px;">
            <div style="font-size:0.75rem; font-weight:bold; color:#00ff41; margin-bottom:4px;">INFLUENCE (Eigenvector)</div>
            <p style="font-size:0.65rem; opacity:0.5; margin:0 0 8px 0;">Papers connected to other highly connected papers</p>
            <div id="dash-list-eigen" style="font-size:0.8rem; line-height:1.4;"><span style="opacity:0.3;">Calculating...</span></div>
        </div>
        <div style="margin-bottom:20px;">
            <div style="font-size:0.75rem; font-weight:bold; color:#00e5ff; margin-bottom:4px;">BRIDGES (Betweenness)</div>
            <p style="font-size:0.65rem; opacity:0.5; margin:0 0 8px 0;">Papers that connect different research clusters</p>
            <div id="dash-list-between" style="font-size:0.8rem; line-height:1.4;"></div>
        </div>
        <div>
            <div style="font-size:0.75rem; font-weight:bold; color:#e040fb; margin-bottom:4px;">HUBS (Degree)</div>
            <p style="font-size:0.65rem; opacity:0.5; margin:0 0 8px 0;">Papers with the most direct relationships</p>
            <div id="dash-list-degree" style="font-size:0.8rem; line-height:1.4;"></div>
        </div>
    </div>
</div>

<div style="grid-column:1; grid-row:3; padding:0; border-right:1px solid var(--card-border, #333); border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; left:20px; z-index:10; pointer-events:none;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase;">Collaboration Network</h4>
        <p style="margin:0; font-size:0.65rem; opacity:0.5;">Co-authorship Connections</p>
    </div>
    <div class="collab-controls" aria-label="Collaboration filters">
        <div class="collab-chip-row" role="group" aria-label="Year range">
            <button class="collab-chip is-active" data-collab-range="all" type="button">All-time</button>
            <button class="collab-chip" data-collab-range="5" type="button">Last 5 yrs</button>
            <button class="collab-chip" data-collab-range="3" type="button">Last 3 yrs</button>
            <button class="collab-chip" data-collab-range="2" type="button">Last 2 yrs</button>
        </div>
    </div>
    <div class="collab-spotlight" id="collab-spotlight" aria-live="polite">
        <div class="collab-spotlight-title">Collaborator spotlight</div>
        <div class="collab-spotlight-body">Select a node to see their co-authorship footprint, top venues, and key connections.</div>
        <div class="collab-spotlight-meta" id="collab-spotlight-meta"></div>
    </div>
    <div id="dashboard-collab-network" style="width:100%; height:100%;"></div>
</div>

<div style="grid-column:2; grid-row:3; padding:0; border-bottom:1px solid var(--card-border, #333); position:relative; height:100%;">
    <div style="position:absolute; top:20px; right:20px; z-index:400; pointer-events:none; text-align:right;">
        <h4 style="margin:0; font-size:0.8rem; opacity:0.7; text-transform:uppercase; color:#333; text-shadow:0 0 5px white;">Research Footprint</h4>
    </div>
    <div class="footprint-controls" aria-label="Footprint controls">
        <div class="footprint-group" role="group" aria-label="Categories">
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Conference" checked> Conferences</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Institution" checked> Institutions</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-cat="Collaboration" checked> Collaborations</label>
        </div>
        <div class="footprint-group" role="group" aria-label="Layers">
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="routes" checked> Routes</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="heat" checked> Heat</label>
            <label class="footprint-check"><input type="checkbox" data-footprint-layer="clusters" checked> Clusters</label>
        </div>
        <div class="footprint-group footprint-timeline" role="group" aria-label="Timeline">
            <span class="footprint-year-label" id="footprint-year-label">Up to â€”</span>
            <input type="range" id="footprint-year-range" min="2018" max="2026" value="2026" step="1" />
        </div>
    </div>
    <div class="footprint-legend" id="footprint-legend"></div>
    <div id="dashboard-footprint-map" style="width:100%; height:100%; z-index:1;"></div>
</div>

<div style="grid-column:1; grid-row:4; padding:25px; border-right:1px solid var(--card-border, #333); display:flex; flex-direction:column;">
    <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin-bottom:15px;">Traffic Overview</h4>
    <div style="display:flex; gap:20px; height:100%;">
        <div style="flex:0 0 100px; display:flex; flex-direction:column; justify-content:center;">
            <div style="margin-bottom:15px;">
                <div style="font-size:0.7rem; opacity:0.6;">Total Visitors</div>
                <div id="dash-visit-total" style="font-size:1.4rem; font-weight:800; color:#00ff41;">0</div>
            </div>
            <div>
                <div style="font-size:0.7rem; opacity:0.6;">Last 30 Days</div>
                <div id="dash-visit-month" style="font-size:1.4rem; font-weight:800; color:#00e5ff;">0</div>
            </div>
        </div>
        <div style="flex-grow:1; position:relative;">
            <div id="dash-visit-trend" style="width:100%; height:100%;"></div>
        </div>
    </div>
</div>

<div style="grid-column:2; grid-row:4; padding:25px; display:flex; flex-direction:column;">
    <h4 style="font-size:0.8rem; opacity:0.7; text-transform:uppercase; margin-bottom:15px;">Audience & Reach</h4>
    <div style="display:flex; gap:20px; height:100%;">
        <div style="flex:1; position:relative;">
            <div id="dash-visit-device" style="width:100%; height:100%;"></div>
        </div>
        <div style="flex:1; overflow-y:auto; border-left:1px solid var(--card-border, #333); padding-left:15px;">
            <div style="font-size:0.7rem; font-weight:bold; margin-bottom:8px; opacity:0.8;">Top 5 Locations</div>
            <div id="dash-visit-locations" style="font-size:0.75rem; line-height:1.5;">
                <span style="opacity:0.5;">Loading...</span>
            </div>
        </div>
    </div>
</div>

</div>
</div>

<style>
/* Leaflet Markers */
.custom-marker { background: transparent; }
.custom-marker .marker-pin { width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 4px rgba(0,0,0,0.3); }
.conference-marker .marker-pin { background: #00ff41; }
.collaboration-marker .marker-pin { background: #00bfff; }
.institution-marker .marker-pin { background: #ff6b35; }
body.dark .custom-marker .marker-pin { border-color: #000; box-shadow: 0 0 8px currentColor; }

/* Impact map controls */
.impact-map-controls { position:absolute; top:16px; right:16px; z-index:20; display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
.impact-control-group { display:flex; flex-wrap:wrap; gap:6px; padding:6px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.impact-toggle { border:1px solid rgba(0,255,65,0.3); background:transparent; color:#b9f6ca; font-size:0.6rem; letter-spacing:0.05em; text-transform:uppercase; padding:4px 8px; border-radius:999px; cursor:pointer; }
.impact-toggle.is-active { background:rgba(0,255,65,0.18); border-color:#00ff41; color:#00ff41; }
.impact-check { display:flex; align-items:center; gap:6px; font-size:0.62rem; color:#cfead2; }
.impact-check input { accent-color:#00ff41; }
.impact-map-legend { position:absolute; bottom:14px; left:14px; z-index:15; max-width:240px; background:rgba(0,0,0,0.4); border:1px solid var(--card-border, #333); border-radius:12px; padding:8px 10px; font-size:0.62rem; color:#d6dde2; backdrop-filter: blur(6px); pointer-events:auto; }
.impact-map-legend .legend-row { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
.impact-map-legend .legend-row:last-child { margin-bottom:0; }
.impact-legend-dot { width:8px; height:8px; border-radius:50%; background:var(--legend-color); box-shadow:0 0 6px rgba(0,0,0,0.4); }
.impact-map-inspector { position:absolute; top:92px; right:16px; width:230px; z-index:20; background:rgba(0,0,0,0.48); border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; font-size:0.62rem; color:#e0e0e0; backdrop-filter: blur(6px); pointer-events:auto; }
.impact-inspector-title { font-size:0.68rem; text-transform:uppercase; opacity:0.7; margin-bottom:6px; }
.impact-inspector-body { line-height:1.4; margin-bottom:8px; opacity:0.9; }
.impact-inspector-actions { display:flex; gap:6px; margin-bottom:8px; }
.impact-action { flex:1; border-radius:999px; border:1px solid rgba(0,255,65,0.3); background:transparent; color:#c8f7c5; font-size:0.58rem; padding:4px 6px; text-transform:uppercase; letter-spacing:0.08em; cursor:pointer; }
.impact-action:disabled { opacity:0.4; cursor:not-allowed; }
.impact-inspector-pins { display:flex; flex-wrap:wrap; gap:6px; }
.impact-pin { display:flex; align-items:center; gap:6px; padding:4px 6px; border-radius:999px; background:rgba(0,229,255,0.12); border:1px solid rgba(0,229,255,0.3); font-size:0.58rem; }
.impact-pin button { border:none; background:transparent; color:#00e5ff; cursor:pointer; font-size:0.7rem; line-height:1; }

/* Collaboration network controls */
.collab-controls { position:absolute; top:16px; right:16px; z-index:20; pointer-events:auto; }
.collab-chip-row { display:flex; flex-wrap:wrap; gap:6px; padding:6px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.collab-chip { border:1px solid rgba(0,229,255,0.3); background:transparent; color:#bde8ff; font-size:0.6rem; letter-spacing:0.04em; text-transform:uppercase; padding:4px 8px; border-radius:999px; cursor:pointer; }
.collab-chip.is-active { background:rgba(0,229,255,0.18); border-color:#00e5ff; color:#00e5ff; }
.collab-spotlight { position:absolute; bottom:16px; left:16px; width:240px; z-index:20; background:rgba(0,0,0,0.48); border:1px solid var(--card-border, #333); border-radius:12px; padding:10px; font-size:0.62rem; color:#e0e0e0; backdrop-filter: blur(6px); pointer-events:auto; }
.collab-spotlight-title { font-size:0.68rem; text-transform:uppercase; opacity:0.7; margin-bottom:6px; }
.collab-spotlight-body { line-height:1.4; margin-bottom:8px; opacity:0.9; }
.collab-spotlight-meta { display:grid; gap:6px; }
.collab-meta-row { display:flex; justify-content:space-between; gap:10px; }
.collab-meta-row span { opacity:0.7; }
.collab-meta-row strong { font-weight:700; color:#00e5ff; }

@media (max-width: 900px) {
    .impact-map-controls { top:12px; right:12px; }
    .impact-map-legend { bottom:12px; left:12px; }
    .impact-map-inspector { top:auto; bottom:12px; right:12px; width:200px; }
    .collab-controls { top:12px; right:12px; }
    .collab-spotlight { bottom:12px; left:12px; width:210px; }
}

body:not(.dark) .impact-control-group,
body:not(.dark) .impact-map-legend,
body:not(.dark) .impact-map-inspector,
body:not(.dark) .collab-chip-row,
body:not(.dark) .collab-spotlight {
    background:rgba(255,255,255,0.85);
    color:#333;
    border-color:#e0e0e0;
}
body:not(.dark) .impact-toggle,
body:not(.dark) .impact-action,
body:not(.dark) .collab-chip { color:#1a1a1a; border-color:#bdbdbd; }
body:not(.dark) .impact-toggle.is-active { color:#0b7a2f; border-color:#0b7a2f; background:rgba(11,122,47,0.15); }
body:not(.dark) .collab-chip.is-active { color:#0077b6; border-color:#0077b6; background:rgba(0,119,182,0.15); }
body:not(.dark) .impact-action { color:#0b7a2f; }
body:not(.dark) .impact-pin { background:rgba(0,119,182,0.12); border-color:rgba(0,119,182,0.3); }

/* Footprint map controls */
.footprint-controls { position:absolute; top:16px; left:16px; z-index:20; display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
.footprint-group { display:flex; flex-wrap:wrap; gap:8px; padding:6px 8px; border-radius:10px; border:1px solid var(--card-border, #333); background:rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
.footprint-check { display:flex; align-items:center; gap:6px; font-size:0.62rem; color:#cfead2; }
.footprint-check input { accent-color:#00e5ff; }
.footprint-timeline { flex-direction:column; align-items:flex-start; gap:6px; }
.footprint-year-label { font-size:0.62rem; letter-spacing:0.04em; text-transform:uppercase; color:#bde8ff; }
.footprint-timeline input[type="range"] { width:200px; }
.footprint-legend { position:absolute; bottom:14px; right:14px; z-index:15; max-width:200px; background:rgba(0,0,0,0.4); border:1px solid var(--card-border, #333); border-radius:12px; padding:8px 10px; font-size:0.62rem; color:#d6dde2; backdrop-filter: blur(6px); pointer-events:none; }
.footprint-legend .legend-row { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
.footprint-legend .legend-row:last-child { margin-bottom:0; }
.footprint-legend-dot { width:8px; height:8px; border-radius:50%; background:var(--legend-color); box-shadow:0 0 6px rgba(0,0,0,0.4); }

.footprint-marker { position:relative; width:16px; height:16px; }
.footprint-marker .ring { position:absolute; inset:-6px; border-radius:50%; border:1.5px solid currentColor; opacity:0.6; animation: footprintPulse 2.6s ease-out infinite; }
.footprint-marker .dot { position:absolute; inset:0; border-radius:50%; background:currentColor; box-shadow:0 0 6px rgba(0,0,0,0.5); }
.footprint-marker.conference { color:#00ff41; }
.footprint-marker.institution { color:#ff6b35; }
.footprint-marker.collaboration { color:#00bfff; }

.footprint-arc { stroke:#00e5ff; stroke-width:1.2; stroke-opacity:0.4; stroke-dasharray:6 10; animation: arcDash 6s linear infinite; }

.marker-cluster-small { background:rgba(0,229,255,0.15) !important; }
.marker-cluster-small div { background:rgba(0,229,255,0.35) !important; color:#0c1f2a !important; }
.marker-cluster-medium { background:rgba(0,255,65,0.15) !important; }
.marker-cluster-medium div { background:rgba(0,255,65,0.35) !important; color:#0c1f2a !important; }
.marker-cluster-large { background:rgba(224,64,251,0.15) !important; }
.marker-cluster-large div { background:rgba(224,64,251,0.35) !important; color:#0c1f2a !important; }

@keyframes footprintPulse { 0% { transform:scale(0.7); opacity:0.6; } 70% { transform:scale(1.6); opacity:0; } 100% { opacity:0; } }
@keyframes arcDash { to { stroke-dashoffset: -32; } }

body:not(.dark) .footprint-group,
body:not(.dark) .footprint-legend { background:rgba(255,255,255,0.9); color:#333; border-color:#e0e0e0; }
body:not(.dark) .footprint-year-label { color:#0b4f6c; }

@media (max-width: 900px) {
    .footprint-controls { top:12px; left:12px; }
    .footprint-legend { bottom:12px; right:12px; }
    .footprint-timeline input[type="range"] { width:160px; }
}
</style>

<script type="text/javascript">
(function() {
    // 1. IDS configuration
    const IDS = {
        RADAR: 'dashboard-radar',
        LINE: 'dashboard-timeline',
        MAP: 'dashboard-impact-map',
        COLLAB: 'dashboard-collab-network',
        FOOTPRINT: 'dashboard-footprint-map',
        VISIT: {
            TREND: 'dash-visit-trend',
            DEVICE: 'dash-visit-device',
            TOTAL: 'dash-visit-total',
            MONTH: 'dash-visit-month',
            LOCS: 'dash-visit-locations'
        },
        METRICS: {
            FOCUS: 'dash-metric-focus', TREND: 'dash-metric-trend',
            CITES: 'dash-metric-cites', HINDEX: 'dash-metric-hindex'
        },
        LISTS: { EIGEN: 'dash-list-eigen', BETWEEN: 'dash-list-between', DEGREE: 'dash-list-degree' }
    };

    const TOPIC_TAXONOMY = {
        'AI / Deep Learning': ['Deep Learning', 'Neural', 'Transfer Learning', 'Embedding', 'Machine Learning', 'Artificial Intelligence', 'Adversarial'],
        'Cybersecurity': ['Cyber', 'Vulnerability', 'Exploit', 'Attack', 'Threat', 'Security', 'Malicious', 'Ransomware', 'Phishing'],
        'LLMs & NLP': ['Large Language Model', 'LLM', 'Text Analytics', 'NLP', 'Transformer', 'Bert', 'GPT', 'Language Models'],
        'Hacker Communities': ['Hacker', 'Forum', 'Dark Web', 'Paste', 'Community', 'Marketplace', 'Underground'],
        'Design Science': ['Design Science', 'Framework', 'Artifact', 'System', 'Implementation', 'Prototyping'],
        'Behavioral': ['Nudging', 'Bias', 'Social', 'Human', 'Behavior', 'Psychology', 'Decision', 'Trust']
    };

    const impactState = {
        colorMode: 'topic',
        linkTypes: { topic: true, venue: true, author: true },
        focusId: null,
        pinned: new Set()
    };

    let collabRange = 'all';
    let collabFocusId = null;

    var radarChart, lineChart, graphChart, collabChart, visitTrendChart, visitDeviceChart;

    // 2. DATA LOADING
    const safeFetch = (url) => fetch(url).then(r => r.ok ? r.json() : null).catch(e => null);

    Promise.all([
        safeFetch('/data/publications.json'),
        safeFetch('/data/scholar-metrics.json'),
        safeFetch('/data/visitor_stats.json')
    ]).then(([papersData, scholarData, visitorData]) => {
        
        let papers = [];
        if (scholarData && scholarData.individualPublications) {
            papers = scholarData.individualPublications;
        } else if (papersData) {
            papers = Array.isArray(papersData) ? papersData : (papersData.individualPublications || []);
        }

        processMetrics(papers, scholarData);

        renderRadar(papers); 
        if(scholarData && scholarData.citationsByYear) renderLine(scholarData.citationsByYear);
        renderWorkingMap(papers); 
        calculateAllMetrics(papers);
        renderCollabNetwork(papers);
        renderFootprintMap();
        
        if(visitorData) renderVisitorStats(visitorData);

    }).catch(err => console.error("Dashboard Error:", err));


    // ========================================================================
    // LOGIC: VISITOR STATS (Row 4)
    // ========================================================================
    function renderVisitorStats(data) {
        updateText(IDS.VISIT.TOTAL, data.lifetime_total || 0);
        updateText(IDS.VISIT.MONTH, data.total_last_30_days || 0);

        // 1. Trend Chart
        var domTrend = document.getElementById(IDS.VISIT.TREND);
        if(domTrend && data.monthly_trend) {
            if(visitTrendChart) visitTrendChart.dispose();
            visitTrendChart = echarts.init(domTrend);
            
            let months = data.monthly_trend.map(d => d.month);
            let counts = data.monthly_trend.map(d => d.visitors);
            
            visitTrendChart.setOption({
                tooltip: { trigger: 'axis' },
                grid: { top: 10, right: 10, bottom: 20, left: 10, containLabel: false },
                xAxis: { show: false, data: months },
                yAxis: { show: false, type: 'value' },
                series: [{
                    type: 'bar',
                    data: counts,
                    itemStyle: { color: '#00ff41', borderRadius: [2,2,0,0] },
                    barWidth: '60%'
                }]
            });
        }

        // 2. Device Chart
        var domDevice = document.getElementById(IDS.VISIT.DEVICE);
        if(domDevice && data.devices) {
            if(visitDeviceChart) visitDeviceChart.dispose();
            visitDeviceChart = echarts.init(domDevice);
            let isDark = document.body.classList.contains('dark');
            
            visitDeviceChart.setOption({
                tooltip: { trigger: 'item' },
                series: [{
                    type: 'pie',
                    radius: ['40%', '70%'],
                    center: ['50%', '50%'],
                    itemStyle: { borderRadius: 4, borderColor: isDark?'#111':'#fff', borderWidth: 2 },
                    label: { show: false },
                    data: data.devices.map(d => ({ name: d.device, value: d.users }))
                }]
            });
        }

        // 3. Top Locations (Filtered Logic)
        var domLocs = document.getElementById(IDS.VISIT.LOCS);
        if(domLocs) {
            // Prioritize 'top_locations' which contains city/country
            let rawList = data.top_locations || data.countries || data.locations || [];
            
            // FIX: Filter empty or "(not set)" values
            const isValid = (value) => value && value.trim() !== "" && value !== "(not set)";
            let list = rawList.filter(d => isValid(d.city) && isValid(d.country));
            
            // Sort by visitors or users
            list.sort((a,b) => (b.visitors || b.users || 0) - (a.visitors || a.users || 0));
            
            // Top 5
            let top5 = list.slice(0, 5);

            if(top5.length > 0) {
                const stateMap = {
                    "Alabama":"AL","Alaska":"AK","Arizona":"AZ","Arkansas":"AR","California":"CA","Colorado":"CO","Connecticut":"CT","Delaware":"DE",
                    "District of Columbia":"DC","Florida":"FL","Georgia":"GA","Hawaii":"HI","Idaho":"ID","Illinois":"IL","Indiana":"IN","Iowa":"IA",
                    "Kansas":"KS","Kentucky":"KY","Louisiana":"LA","Maine":"ME","Maryland":"MD","Massachusetts":"MA","Michigan":"MI","Minnesota":"MN",
                    "Mississippi":"MS","Missouri":"MO","Montana":"MT","Nebraska":"NE","Nevada":"NV","New Hampshire":"NH","New Jersey":"NJ",
                    "New Mexico":"NM","New York":"NY","North Carolina":"NC","North Dakota":"ND","Ohio":"OH","Oklahoma":"OK","Oregon":"OR",
                    "Pennsylvania":"PA","Rhode Island":"RI","South Carolina":"SC","South Dakota":"SD","Tennessee":"TN","Texas":"TX","Utah":"UT",
                    "Vermont":"VT","Virginia":"VA","Washington":"WA","West Virginia":"WV","Wisconsin":"WI","Wyoming":"WY"
                };

                const normalizeCountry = (country) => {
                    if (country === "United States") return "USA";
                    return country;
                };

                const normalizeRegion = (region, country) => {
                    if (!isValid(region)) return "";
                    if (country === "United States" && stateMap[region]) return stateMap[region];
                    return region;
                };

                let html = top5.map(c => {
                    const city = c.city;
                    const country = normalizeCountry(c.country);
                    const region = normalizeRegion(c.region, c.country);
                    const parts = [city, region, country].filter(Boolean);
                    const fullName = parts.join(", ");
                    const count = c.visitors || c.users || 0;
                    
                    return `<div style="display:flex; justify-content:space-between; margin-bottom:4px;" title="${fullName}">
                        <span style="opacity:0.7; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:180px;">${fullName}</span>
                        <span style="font-weight:bold; color:#e040fb;">${count}</span>
                    </div>`;
                }).join('');
                domLocs.innerHTML = html;
            } else {
                domLocs.innerHTML = '<span style="opacity:0.5">No location data</span>';
            }
        }
    }


    // ========================================================================
    // LOGIC: METRICS & RADAR
    // ========================================================================
    function processMetrics(papers, scholarData) {
        let counts = {};
        let recentCounts = {};
        let currentYear = new Date().getFullYear();
        Object.keys(TOPIC_TAXONOMY).forEach(k => { counts[k] = 0; recentCounts[k] = 0; });

        papers.forEach(p => {
            let text = (p.title || "").toLowerCase();
            Object.keys(TOPIC_TAXONOMY).forEach(cat => {
                if(TOPIC_TAXONOMY[cat].some(k => text.includes(k.toLowerCase()))) {
                    counts[cat]++;
                    if(p.year >= currentYear - 2) recentCounts[cat]++;
                }
            });
        });

        let topSkill = Object.entries(counts).sort((a,b) => b[1]-a[1])[0];
        let trendSkill = Object.entries(recentCounts).sort((a,b) => b[1]-a[1])[0];
        updateText(IDS.METRICS.FOCUS, topSkill ? topSkill[0] : "Cybersecurity");
        updateText(IDS.METRICS.TREND, trendSkill ? trendSkill[0] : "AI");
        if(scholarData && scholarData.metrics) {
            updateText(IDS.METRICS.CITES, scholarData.metrics.citations || 0);
            updateText(IDS.METRICS.HINDEX, scholarData.metrics.hIndex || 0);
        }
        
        renderRadarChart(counts, recentCounts); 
    }

    function renderRadarChart(counts, recentCounts) {
        var dom = document.getElementById(IDS.RADAR);
        if(!dom) return;
        if(radarChart) radarChart.dispose();
        radarChart = echarts.init(dom);
        const icons = {
            'AI / Deep Learning': 'ðŸ§ ',
            'Cybersecurity': 'ðŸ”',
            'LLMs & NLP': 'ðŸ’¬',
            'Hacker Communities': 'ðŸ•¶ï¸',
            'Design Science': 'ðŸ§ª',
            'Behavioral': 'ðŸ§­'
        };
        let categories = Object.keys(counts);
        let data = categories.map(k => ({ name: k, value: counts[k] }));
        let recent = categories.map(k => recentCounts[k] || 0);
        let max = Math.max(...data.map(d => d.value)) || 1;
        let isDark = document.body.classList.contains('dark');
        const labelColor = isDark ? '#aaa' : '#333';
        radarChart.setOption({
            tooltip: { trigger: 'item' },
            radar: {
                indicator: data.map(d => ({ name: d.name, max: max + 2 })),
                shape: 'circle',
                splitArea: { show: false },
                axisName: {
                    color: labelColor,
                    formatter: function(value) {
                        const icon = icons[value] || '';
                        const short = value.replace(' / ', ' ').replace(' & ', ' ');
                        return icon ? `${icon} ${short}` : short;
                    }
                }
            },
            series: [
                {
                    type: 'radar',
                    data: [
                        {
                            value: data.map(d => d.value),
                            name: 'All-time',
                            itemStyle: { color: isDark ? '#00ff41' : '#d93025' },
                            areaStyle: { opacity: 0.15 }
                        },
                        {
                            value: recent,
                            name: 'Last 2 Years',
                            itemStyle: { color: isDark ? '#00e5ff' : '#1a73e8' },
                            areaStyle: { opacity: 0.25 }
                        }
                    ]
                }
            ]
        });
    }
    
    function renderRadar(papers) { }


    // ========================================================================
    // LOGIC: IMPACT MAP (UPDATED TOOLTIP)
    // ========================================================================
    function renderWorkingMap(papers) {
        var dom = document.getElementById(IDS.MAP);
        if(!dom || papers.length === 0) return;
        if(graphChart) graphChart.dispose();
        graphChart = echarts.init(dom);
        
        const STOP_WORDS = new Set(['the','of','and','in','to','a','for','on','with','using','an','based','via','system','analysis','approach','study','framework','model','data','from','by','detection','paper','research','towards']);
        const WEIGHT_TOPIC = 1.0;
        const WEIGHT_VENUE = 2.0;
        const WEIGHT_AUTHOR = 3.0;
        const LINK_THRESHOLD = 1.5;
        const topicPalette = ['#00ff41', '#00e5ff', '#e040fb', '#ffd166', '#ff6b35', '#7c4dff', '#4dd0e1', '#80cbc4'];
        const topicColors = {};
        const topics = Object.keys(TOPIC_TAXONOMY);
        topics.forEach((t, i) => { topicColors[t] = topicPalette[i % topicPalette.length]; });
        if (!topicColors.Other) topicColors.Other = '#9e9e9e';

        let nodes = [];
        let linksRaw = [];
        let citationValues = [];

        papers.forEach((p, index) => {
            let words = (p.title||"").toLowerCase().replace(/[^a-z0-9 ]/g, '').split(/\s+/).filter(w => w.length > 3 && !STOP_WORDS.has(w));
            p._words = new Set(words);
            p._authors = new Set();
            if(p.authors) {
                let authStr = Array.isArray(p.authors) ? p.authors.join(',') : p.authors;
                authStr.split(',').forEach(a => {
                    let clean = a.trim().toLowerCase();
                    if(!clean.includes('ampel')) p._authors.add(clean);
                });
            }
            p._venue = p.venue ? p.venue.toLowerCase().trim() : "";

            const text = (p.title || "").toLowerCase();
            let topic = 'Other';
            for (let i = 0; i < topics.length; i++) {
                const cat = topics[i];
                if (TOPIC_TAXONOMY[cat].some(k => text.includes(k.toLowerCase()))) {
                    topic = cat;
                    break;
                }
            }
            const citations = p.citations || 0;
            citationValues.push(citations);
            nodes.push({
                id: index,
                name: p.title,
                value: citations,
                year: p.year,
                authors: p.authors,
                venue: p.venue,
                topic: topic,
                yearColor: getColorByYear(p.year),
                topicColor: topicColors[topic] || topicColors.Other,
                symbolSize: Math.max(10, Math.min(65, Math.log((citations) + 2) * 9)),
                label: { show: false, formatter: p => p.name.length > 18 ? p.name.substring(0, 18) + '...' : p.name }
            });
        });

        impactState.pinned = new Set(Array.from(impactState.pinned).filter(id => id >= 0 && id < nodes.length));

        for (let i = 0; i < papers.length; i++) {
            for (let j = i + 1; j < papers.length; j++) {
                let p1 = papers[i];
                let p2 = papers[j];
                let score = 0;
                let reasons = [];
                let commonWords = 0;
                p1._words.forEach(w => { if (p2._words.has(w)) commonWords++; });
                if (commonWords > 0) { score += (commonWords * WEIGHT_TOPIC); reasons.push(`${commonWords} Keywords`); }
                if (p1._venue && p2._venue && p1._venue === p2._venue) { score += WEIGHT_VENUE; reasons.push("Same Venue"); }
                let commonAuthors = 0;
                p1._authors.forEach(a => { if (p2._authors.has(a)) commonAuthors++; });
                if (commonAuthors > 0) { score += (commonAuthors * WEIGHT_AUTHOR); reasons.push(`${commonAuthors} Co-Authors`); }

                if (score >= LINK_THRESHOLD) {
                    let avgCites = ((p1.citations || 0) + (p2.citations || 0)) / 2;
                    let impactBonus = Math.log(avgCites + 1) * 1.5;
                    linksRaw.push({
                        source: i, target: j, value: score + impactBonus, reason: reasons.join(", "),
                        types: { topic: commonWords > 0, venue: (p1._venue && p2._venue && p1._venue === p2._venue), author: commonAuthors > 0 },
                        lineStyle: { width: Math.min((score * 0.5) + impactBonus, 5), opacity: Math.min(0.15 + (score * 0.1), 0.7), curveness: 0.2 }
                    });
                }
            }
        }

        let isDark = document.body.classList.contains('dark');
        const citationThreshold = citationValues.length ? citationValues.sort((a,b) => a - b)[Math.floor(citationValues.length * 0.75)] : 0;

        const legendEl = document.getElementById('impact-map-legend');
        const inspectorEl = document.getElementById('impact-map-inspector');
        const inspectorBody = inspectorEl ? inspectorEl.querySelector('.impact-inspector-body') : null;
        const inspectorPin = inspectorEl ? inspectorEl.querySelector('[data-impact-action="pin"]') : null;
        const inspectorClear = inspectorEl ? inspectorEl.querySelector('[data-impact-action="clear"]') : null;
        const pinsEl = document.getElementById('impact-map-pins');

        function renderLegend() {
            if (!legendEl) return;
            if (impactState.colorMode === 'topic') {
                const usedTopics = Array.from(new Set(nodes.map(n => n.topic)));
                legendEl.innerHTML = usedTopics.map(t => {
                    const color = topicColors[t] || topicColors.Other;
                    return `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${color};"></span><span>${t}</span></div>`;
                }).join('');
            } else {
                legendEl.innerHTML = [
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2018)};"></span><span>2019 &amp; earlier</span></div>`,
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2021)};"></span><span>2020 - 2022</span></div>`,
                    `<div class="legend-row"><span class="impact-legend-dot" style="--legend-color:${getColorByYear(2024)};"></span><span>2023 - present</span></div>`
                ].join('');
            }
        }

        function renderPins() {
            if (!pinsEl) return;
            if (impactState.pinned.size === 0) {
                pinsEl.innerHTML = '';
                return;
            }
            pinsEl.innerHTML = Array.from(impactState.pinned).map(id => {
                const node = nodes[id];
                const label = node ? (node.name.length > 26 ? node.name.slice(0, 26) + '...' : node.name) : 'Pinned';
                return `<div class="impact-pin"><span>${label}</span><button type="button" data-pin-remove="${id}">Ã—</button></div>`;
            }).join('');
        }

        function setInspector(node) {
            if (!inspectorBody || !inspectorPin || !inspectorClear) return;
            if (!node) {
                inspectorBody.textContent = 'Click a node to reveal context, then pin highlights you want to keep.';
                inspectorPin.disabled = true;
                inspectorClear.disabled = true;
            } else {
                inspectorBody.innerHTML = `<strong>${node.name}</strong><br>
                    <span style="opacity:0.8">Topic: ${node.topic}</span><br>
                    <span style="opacity:0.8">Venue: ${node.venue || 'â€”'}</span><br>
                    <span style="opacity:0.8">Year: ${node.year || 'â€”'} Â· Citations: ${node.value}</span>`;
                inspectorPin.disabled = false;
                inspectorClear.disabled = false;
            }
        }

        function getFilteredLinks() {
            const types = impactState.linkTypes;
            return linksRaw.filter(link => {
                return (types.topic && link.types.topic) || (types.venue && link.types.venue) || (types.author && link.types.author);
            });
        }

        function updateImpactGraph() {
            const activeLinks = getFilteredLinks();
            const neighborMap = new Map();
            activeLinks.forEach(l => {
                if (!neighborMap.has(l.source)) neighborMap.set(l.source, new Set());
                if (!neighborMap.has(l.target)) neighborMap.set(l.target, new Set());
                neighborMap.get(l.source).add(l.target);
                neighborMap.get(l.target).add(l.source);
            });

            const highlight = new Set(impactState.pinned);
            if (impactState.focusId !== null && impactState.focusId !== undefined) {
                highlight.add(impactState.focusId);
                const neighbors = neighborMap.get(impactState.focusId);
                if (neighbors) neighbors.forEach(n => highlight.add(n));
            }

            const focusActive = impactState.focusId !== null && impactState.focusId !== undefined;
            const styledNodes = nodes.map(n => {
                const isFocus = n.id === impactState.focusId;
                const isHighlight = highlight.has(n.id);
                const baseColor = impactState.colorMode === 'topic' ? n.topicColor : n.yearColor;
                const isPinned = impactState.pinned.has(n.id);
                const showLabel = isFocus || isPinned;
                return Object.assign({}, n, {
                    itemStyle: {
                        color: baseColor,
                        opacity: focusActive ? (isHighlight ? 1 : 0.08) : 1,
                        borderColor: isFocus ? '#fff' : (isPinned ? '#00e5ff' : 'transparent'),
                        borderWidth: isFocus ? 2 : (isPinned ? 1 : 0)
                    },
                    label: {
                        show: showLabel,
                        color: isDark ? '#eee' : '#222',
                        position: 'right',
                        formatter: p => p.name.length > 18 ? p.name.substring(0, 18) + 'â€¦' : p.name
                    },
                    emphasis: {
                        label: {
                            show: true,
                            color: isDark ? '#fff' : '#111',
                            fontWeight: 'bold',
                            formatter: p => p.name.length > 28 ? p.name.substring(0, 28) + 'â€¦' : p.name
                        }
                    }
                });
            });

            const styledLinks = activeLinks.map(l => {
                const linkHighlight = !focusActive || (highlight.has(l.source) && highlight.has(l.target));
                return Object.assign({}, l, {
                    lineStyle: Object.assign({}, l.lineStyle, {
                        opacity: focusActive ? (linkHighlight ? Math.min(0.65, l.lineStyle.opacity + 0.15) : 0.03) : Math.min(0.25, l.lineStyle.opacity),
                        color: isDark ? '#aaa' : '#666'
                    })
                });
            });

            graphChart.setOption({
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'item',
                    confine: true,
                    position: function (point, params, dom, rect, size) {
                        return [point[0] - (size.contentSize[0] / 2), point[1] - size.contentSize[1] - 20];
                    },
                    formatter: (p) => {
                        if (p.dataType === 'edge') {
                            return `<div style="max-width:200px; white-space:normal;"><strong>Connection</strong><br>Strength: ${Math.floor(p.value)}<br>${p.data.reason}</div>`;
                        }
                        return `<div style="max-width:260px; white-space:normal; word-wrap:break-word;">
                                    <strong>${p.name}</strong><br>
                                    <span style="opacity:0.8">Topic: ${p.data.topic}</span><br>
                                    <span style="opacity:0.8">Venue: ${p.data.venue || 'â€”'}</span><br>
                                    <span style="opacity:0.8">Year: ${p.data.year || 'â€”'} Â· Citations: ${p.value}</span>
                                </div>`;
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'force',
                    data: styledNodes,
                    links: styledLinks,
                    roam: true,
                    zoom: 0.75,
                    label: { position: 'right' },
                    lineStyle: { color: isDark ? '#aaa' : '#666' },
                    force: { repulsion: 500, gravity: 0.1, edgeLength: [50, 300] }
                }]
            }, false);
        }

        function setupImpactControls() {
            const controls = document.querySelector('.impact-map-controls');
            if (controls && !controls.dataset.bound) {
                controls.dataset.bound = 'true';
                controls.addEventListener('click', (e) => {
                    const btn = e.target.closest('button[data-impact-color]');
                    if (btn) {
                        impactState.colorMode = btn.getAttribute('data-impact-color');
                        controls.querySelectorAll('.impact-toggle').forEach(b => b.classList.toggle('is-active', b === btn));
                        renderLegend();
                        updateImpactGraph();
                    }
                });
                controls.querySelectorAll('input[data-impact-link]').forEach(input => {
                    input.addEventListener('change', () => {
                        impactState.linkTypes[input.getAttribute('data-impact-link')] = input.checked;
                        updateImpactGraph();
                    });
                });
            }

            if (inspectorEl && !inspectorEl.dataset.bound) {
                inspectorEl.dataset.bound = 'true';
                inspectorEl.addEventListener('click', (e) => {
                    const action = e.target.closest('[data-impact-action]');
                    if (action) {
                        const type = action.getAttribute('data-impact-action');
                        if (type === 'pin' && impactState.focusId !== null) {
                            impactState.pinned.add(impactState.focusId);
                            renderPins();
                            updateImpactGraph();
                        }
                        if (type === 'clear') {
                            impactState.focusId = null;
                            setInspector(null);
                            updateImpactGraph();
                        }
                    }
                    const removeBtn = e.target.closest('[data-pin-remove]');
                    if (removeBtn) {
                        const id = parseInt(removeBtn.getAttribute('data-pin-remove'), 10);
                        impactState.pinned.delete(id);
                        renderPins();
                        updateImpactGraph();
                    }
                });
            }
        }

        setupImpactControls();
        renderLegend();
        renderPins();
        setInspector(null);
        updateImpactGraph();

        graphChart.off('click');
        graphChart.on('click', (params) => {
            if (params.dataType === 'node') {
                if (impactState.focusId === params.data.id) {
                    impactState.focusId = null;
                    setInspector(null);
                } else {
                    impactState.focusId = params.data.id;
                    setInspector(params.data);
                }
                updateImpactGraph();
            }
        });

        const btn = document.querySelector('.js-theme-toggle');
        if(btn && !btn.dataset.impactBound) {
            btn.dataset.impactBound = 'true';
            btn.addEventListener('click', () => {
                setTimeout(() => {
                    isDark = document.body.classList.contains('dark');
                    updateImpactGraph();
                }, 100);
            });
        }
    }


    // ========================================================================
    // LOGIC: COLLABORATION NETWORK
    // ========================================================================
    function renderCollabNetwork(papers) {
        var dom = document.getElementById(IDS.COLLAB);
        if(!dom) return;
        if(collabChart) collabChart.dispose();
        collabChart = echarts.init(dom);

        var myName = "Benjamin Ampel";
        var nameMap = {
            'B Ampel': 'Benjamin Ampel', 'BM Ampel': 'Benjamin Ampel', 'B. Ampel': 'Benjamin Ampel', 'admin': 'Benjamin Ampel',
            'H Chen': 'Hsinchun Chen', 'H. Chen': 'Hsinchun Chen',
            'S Samtani': 'Sagar Samtani', 'S. Samtani': 'Sagar Samtani',
            'S Ullman': 'Steven Ullman', 'S. Ullman': 'Steven Ullman',
            'H Zhu': 'Hongyi Zhu', 'H. Zhu': 'Hongyi Zhu',
            'M Patton': 'Mark Patton', 'M. Patton': 'Mark Patton',
            'B Lazarine': 'Ben Lazarine', 'B. Lazarine': 'Ben Lazarine',
            'T Vahedi': 'Tala Vahedi', 'T. Vahedi': 'Tala Vahedi',
            'K Otto': 'Kaeli Otto', 'K. Otto': 'Kaeli Otto',
            'Y Gao': 'Yang Gao', 'Y. Gao': 'Yang Gao',
            'J Hu': 'James Hu', 'J. Hu': 'James Hu',
            'CH Yang': 'Chi-Heng Yang', 'JF Nunamaker Jr': 'Jay Nunamaker',
            'C Marx': 'Carolin Marx', 'C Dacosta': 'Cade Dacosta',
            'C Zhang': 'Chengjun Zhang', 'M Hashim': 'Matthew Hashim',
            'M Wagner': 'Mason Wagner', 'RY Reyes': 'Raul Reyes',
            'S Yang': 'Shanchieh Yang', 'Y Li': 'Yidong Li', 'Y. Li': 'Yidong Li'
        };
        function normalize(name) {
            if (!name) return '';
            let clean = name.replace(/\s+/g, ' ').trim();
            if (clean.includes(',')) {
                const parts = clean.split(',').map(p => p.trim()).filter(Boolean);
                if (parts.length >= 2) clean = `${parts[1]} ${parts[0]}`;
            }
            return nameMap[clean] || clean;
        }

        const chipRow = document.querySelector('.collab-chip-row');
        if (chipRow) {
            chipRow.querySelectorAll('.collab-chip').forEach(chip => {
                chip.classList.toggle('is-active', chip.getAttribute('data-collab-range') === collabRange);
                if (!chip.dataset.bound) {
                    chip.dataset.bound = 'true';
                    chip.addEventListener('click', () => {
                        collabRange = chip.getAttribute('data-collab-range');
                        collabFocusId = null;
                        renderCollabNetwork(papers);
                    });
                }
            });
        }

        const currentYear = new Date().getFullYear();
        let filteredPapers = papers;
        if (collabRange !== 'all') {
            const yearsBack = parseInt(collabRange, 10) || 0;
            const minYear = currentYear - yearsBack + 1;
            filteredPapers = papers.filter(p => (p.year || 0) >= minYear);
        }

        var nodeCounts = new Map();
        var linkCounts = new Map();
        var authorMeta = new Map();
        var maxCount = 0;

        filteredPapers.forEach(function(paper) {
            var rawAuthors = paper.authors;
            if (!rawAuthors) return;
            var authorList = Array.isArray(rawAuthors) ? rawAuthors : rawAuthors.split(',');
            var authors = [...new Set(authorList.map(a => normalize(a.trim())).filter(a => a))];

            authors.forEach(auth => {
                let count = (nodeCounts.get(auth) || 0) + 1;
                nodeCounts.set(auth, count);
                if (auth !== myName && count > maxCount) maxCount = count;

                if (!authorMeta.has(auth)) {
                    authorMeta.set(auth, { count: 0, years: new Set(), venues: new Map(), coauthors: new Map() });
                }
                const meta = authorMeta.get(auth);
                meta.count += 1;
                if (paper.year) meta.years.add(paper.year);
                if (paper.venue) meta.venues.set(paper.venue, (meta.venues.get(paper.venue) || 0) + 1);
            });

            for (let i = 0; i < authors.length; i++) {
                for (let j = i + 1; j < authors.length; j++) {
                    let source = authors[i], target = authors[j];
                    if (source === target) continue;
                    let pairId = [source, target].sort().join("|");
                    linkCounts.set(pairId, (linkCounts.get(pairId) || 0) + 1);

                    const metaA = authorMeta.get(source);
                    const metaB = authorMeta.get(target);
                    if (metaA) metaA.coauthors.set(target, (metaA.coauthors.get(target) || 0) + 1);
                    if (metaB) metaB.coauthors.set(source, (metaB.coauthors.get(source) || 0) + 1);
                }
            }
        });

        var nodes = Array.from(nodeCounts.entries()).map(([name, count]) => {
            let isMe = (name === myName);
            return {
                id: name,
                name: name,
                value: count,
                symbolSize: isMe ? 60 : Math.max(18, Math.min(52, count * 7)),
                itemStyle: { color: isMe ? '#ffffff' : null },
                fixed: isMe,
                x: isMe ? dom.clientWidth / 2 : null,
                y: isMe ? dom.clientHeight / 2 : null
            };
        });

        var links = Array.from(linkCounts.entries()).map(([id, count]) => {
            let [source, target] = id.split("|");
            return {
                source: source, target: target, value: count,
                lineStyle: { width: Math.min(1.5 + (count * 0.8), 6), opacity: 0.6 }
            };
        });

        function getCollabColor(val, max, isDark) {
            var ratio = Math.min(Math.max((val - 1) / (max - 1 || 1), 0), 1);
            var hue = (1 - ratio) * 120;
            return isDark ? `hsl(${hue}, 90%, 60%)` : `hsl(${hue}, 80%, 40%)`;
        }

        const spotlight = document.getElementById('collab-spotlight-meta');
        const spotlightBody = document.querySelector('.collab-spotlight-body');
        const spotlightTitle = document.querySelector('.collab-spotlight-title');

        function setSpotlight(name) {
            if (!spotlight || !spotlightBody || !spotlightTitle) return;
            if (!name || !authorMeta.has(name)) {
                spotlightTitle.textContent = 'Collaborator spotlight';
                spotlightBody.textContent = 'Select a node to see their co-authorship footprint, top venues, and key connections.';
                spotlight.innerHTML = '';
                return;
            }
            const meta = authorMeta.get(name);
            const years = Array.from(meta.years).sort();
            const yearRange = years.length ? `${years[0]} - ${years[years.length - 1]}` : 'â€”';
            const topVenues = Array.from(meta.venues.entries()).sort((a,b) => b[1]-a[1]).slice(0, 3).map(v => v[0]).join(', ') || 'â€”';
            const topCoauthors = Array.from(meta.coauthors.entries()).sort((a,b) => b[1]-a[1]).slice(0, 3).map(c => `${c[0]} (${c[1]})`).join(', ') || 'â€”';

            spotlightTitle.textContent = name;
            spotlightBody.textContent = `${meta.count} co-authored papers`;
            spotlight.innerHTML = `
                <div class="collab-meta-row"><span>Active years</span><strong>${yearRange}</strong></div>
                <div class="collab-meta-row"><span>Top venues</span><strong>${topVenues}</strong></div>
                <div class="collab-meta-row"><span>Key co-authors</span><strong>${topCoauthors}</strong></div>
            `;
        }

        function updateCollabGraph() {
            const neighborMap = new Map();
            links.forEach(l => {
                if (!neighborMap.has(l.source)) neighborMap.set(l.source, new Set());
                if (!neighborMap.has(l.target)) neighborMap.set(l.target, new Set());
                neighborMap.get(l.source).add(l.target);
                neighborMap.get(l.target).add(l.source);
            });

            const highlight = new Set();
            if (collabFocusId) {
                highlight.add(collabFocusId);
                const neighbors = neighborMap.get(collabFocusId);
                if (neighbors) neighbors.forEach(n => highlight.add(n));
            }

            let isDark = document.body.classList.contains('dark');
            const styledNodes = nodes.map(n => {
                const isFocus = collabFocusId === n.id;
                const isHighlight = highlight.size === 0 || highlight.has(n.id);
                const baseColor = n.id === myName ? (isDark ? '#fff' : '#000') : getCollabColor(n.value, maxCount, isDark);
                return Object.assign({}, n, {
                    itemStyle: {
                        color: baseColor,
                        opacity: highlight.size === 0 ? 1 : (isHighlight ? 1 : 0.08),
                        borderColor: isFocus ? '#00e5ff' : (n.id === myName ? (isDark ? '#000' : '#fff') : 'transparent'),
                        borderWidth: isFocus ? 2 : (n.id === myName ? 2 : 0)
                    },
                    label: { show: n.value > 1 || n.id === myName || isHighlight, color: isDark?'#eee':'#333' }
                });
            });

            const styledLinks = links.map(l => {
                const linkHighlight = highlight.size === 0 || (highlight.has(l.source) && highlight.has(l.target));
                return Object.assign({}, l, {
                    lineStyle: Object.assign({}, l.lineStyle, {
                        opacity: highlight.size === 0 ? l.lineStyle.opacity : (linkHighlight ? Math.min(0.8, l.lineStyle.opacity + 0.2) : 0.05),
                        color: getCollabColor(l.value, maxCount, isDark)
                    })
                });
            });

            collabChart.setOption({
                backgroundColor: 'transparent',
                tooltip: { formatter: p => p.dataType==='edge' ? `${p.data.source} & ${p.data.target}<br>${p.value} Papers` : `${p.name}: ${p.value} Papers` },
                series: [{
                    type: 'graph', layout: 'force', data: styledNodes, links: styledLinks, roam: true, zoom: 0.6,
                    label: { position: 'right' },
                    lineStyle: { curveness: 0.2 },
                    force: { repulsion: 800, gravity: 0.1, edgeLength: [30, 150] }
                }]
            }, false);
        }

        if (collabFocusId && !nodeCounts.has(collabFocusId)) {
            collabFocusId = null;
        }

        setSpotlight(collabFocusId);
        updateCollabGraph();

        collabChart.off('click');
        collabChart.on('click', (params) => {
            if (params.dataType === 'node') {
                if (collabFocusId === params.data.id) {
                    collabFocusId = null;
                    setSpotlight(null);
                } else {
                    collabFocusId = params.data.id;
                    setSpotlight(collabFocusId);
                }
                updateCollabGraph();
            }
        });

        const btn = document.querySelector('.js-theme-toggle');
        if(btn && !btn.dataset.collabBound) {
            btn.dataset.collabBound = 'true';
            btn.addEventListener('click', () => { setTimeout(() => { updateCollabGraph(); }, 100); });
        }
    }


    // ========================================================================
    // LOGIC: FOOTPRINT MAP
    // ========================================================================
    function renderFootprintMap() {
        var container = document.getElementById(IDS.FOOTPRINT);
        if(!container) return;
        
        var map = L.map(IDS.FOOTPRINT).setView([30, -20], 2);

        var lightTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 18 });
        var darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 18 });

        if (document.body.classList.contains('dark')) { darkTiles.addTo(map); } else { lightTiles.addTo(map); }

        var points = [
            {{ range $.Site.Data.impact_map }}
            { "title": "{{ .title }}", "lat": {{ .lat }}, "lng": {{ .lng }}, "location": "{{ .location }}", "desc": "{{ .description }}", "cat": "{{ .category }}" },
            {{ end }}
        ];

        const categoryColors = {
            Conference: '#00ff41',
            Collaboration: '#00bfff',
            Institution: '#ff6b35'
        };

        function extractYears(text) {
            if (!text) return [];
            const matches = text.match(/(19|20)\d{2}/g) || [];
            return matches.map(v => parseInt(v, 10)).filter(y => y > 1900 && y < 2100);
        }

        const enrichedPoints = points.map(p => {
            const years = [...new Set([...extractYears(p.title), ...extractYears(p.desc)])].sort();
            const minYear = years.length ? years[0] : null;
            const maxYear = years.length ? years[years.length - 1] : null;
            return Object.assign({}, p, { years: years, minYear: minYear, maxYear: maxYear });
        });

        const yearValues = enrichedPoints.filter(p => p.minYear).map(p => p.maxYear || p.minYear);
        const minYear = yearValues.length ? Math.min(...yearValues) : (new Date().getFullYear() - 6);
        const maxYear = yearValues.length ? Math.max(...yearValues) : new Date().getFullYear();

        const state = {
            categories: { Conference: true, Collaboration: true, Institution: true },
            layers: { routes: true, heat: true, clusters: true },
            year: maxYear
        };

        const legendEl = document.getElementById('footprint-legend');
        if (legendEl) {
            legendEl.innerHTML = Object.keys(categoryColors).map(cat => (
                `<div class="legend-row"><span class="footprint-legend-dot" style="--legend-color:${categoryColors[cat]};"></span><span>${cat}</span></div>`
            )).join('');
        }

        const rangeEl = document.getElementById('footprint-year-range');
        const labelEl = document.getElementById('footprint-year-label');
        if (rangeEl && labelEl) {
            rangeEl.min = minYear;
            rangeEl.max = maxYear;
            rangeEl.value = maxYear;
            labelEl.textContent = `Up to ${maxYear}`;
            rangeEl.addEventListener('input', () => {
                state.year = parseInt(rangeEl.value, 10);
                labelEl.textContent = `Up to ${state.year}`;
                applyFilters();
            });
        }

        function createIcon(category) {
            const cls = category.toLowerCase();
            return L.divIcon({
                className: '',
                html: `<div class="footprint-marker ${cls}"><span class="ring"></span><span class="dot"></span></div>`,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        const markerLayer = L.layerGroup();
        const arcLayer = L.layerGroup().addTo(map);
        const clusterLayer = (L.markerClusterGroup ? L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 50 }) : null);
        const heatLayer = (L.heatLayer ? L.heatLayer([], { radius: 26, blur: 18, maxZoom: 4, minOpacity: 0.12, gradient: { 0.0: 'rgba(0,0,0,0)', 0.4: '#00bfff', 0.7: '#00ff41', 1.0: '#e040fb' } }) : null);

        function withinYear(point) {
            if (!point.minYear) return true;
            return point.minYear <= state.year;
        }

        function buildMarkers(list) {
            markerLayer.clearLayers();
            if (clusterLayer) clusterLayer.clearLayers();
            list.forEach(point => {
                const icon = createIcon(point.cat || 'Collaboration');
                const popup = `<div><strong>${point.title}</strong><br><span style="font-size:0.8em">${point.location}</span><br><span style="font-size:0.8em;opacity:0.7">${point.cat}</span></div>`;
                const marker = L.marker([point.lat, point.lng], { icon: icon }).bindPopup(popup);
                if (state.layers.clusters && clusterLayer) {
                    clusterLayer.addLayer(marker);
                } else {
                    markerLayer.addLayer(marker);
                }
            });

            if (state.layers.clusters && clusterLayer) {
                if (!map.hasLayer(clusterLayer)) map.addLayer(clusterLayer);
                if (map.hasLayer(markerLayer)) map.removeLayer(markerLayer);
            } else {
                if (!map.hasLayer(markerLayer)) map.addLayer(markerLayer);
                if (clusterLayer && map.hasLayer(clusterLayer)) map.removeLayer(clusterLayer);
            }
        }

        function createArc(latlng1, latlng2) {
            const lat1 = latlng1.lat, lng1 = latlng1.lng;
            const lat2 = latlng2.lat, lng2 = latlng2.lng;
            const midLat = (lat1 + lat2) / 2;
            const midLng = (lng1 + lng2) / 2;
            const dx = lng2 - lng1;
            const dy = lat2 - lat1;
            const norm = Math.sqrt(dx * dx + dy * dy) || 1;
            const offset = Math.min(12, norm * 0.25);
            const ctrlLat = midLat + (-dx / norm) * offset;
            const ctrlLng = midLng + (dy / norm) * offset;
            const coords = [];
            for (let t = 0; t <= 1.001; t += 0.06) {
                const lat = (1 - t) * (1 - t) * lat1 + 2 * (1 - t) * t * ctrlLat + t * t * lat2;
                const lng = (1 - t) * (1 - t) * lng1 + 2 * (1 - t) * t * ctrlLng + t * t * lng2;
                coords.push([lat, lng]);
            }
            return coords;
        }

        function buildArcs(list) {
            arcLayer.clearLayers();
            if (!state.layers.routes) return;
            const routePoints = list
                .filter(p => p.minYear)
                .filter(p => p.cat === 'Conference' || p.cat === 'Institution')
                .sort((a, b) => (a.minYear || 9999) - (b.minYear || 9999));

            for (let i = 0; i < routePoints.length - 1; i++) {
                const start = routePoints[i];
                const end = routePoints[i + 1];
                const arc = L.polyline(createArc({ lat: start.lat, lng: start.lng }, { lat: end.lat, lng: end.lng }), { className: 'footprint-arc' });
                arcLayer.addLayer(arc);
            }
        }

        function buildHeat(list) {
            if (!heatLayer) return;
            if (!state.layers.heat) {
                if (map.hasLayer(heatLayer)) map.removeLayer(heatLayer);
                return;
            }
            const weights = { Conference: 0.8, Institution: 0.9, Collaboration: 0.6 };
            const heatPoints = list.map(p => [p.lat, p.lng, weights[p.cat] || 0.5]);
            heatLayer.setLatLngs(heatPoints);
            if (!map.hasLayer(heatLayer)) heatLayer.addTo(map);
        }

        function applyFilters() {
            const filtered = enrichedPoints.filter(p => state.categories[p.cat] && withinYear(p));
            buildMarkers(filtered);
            buildArcs(filtered);
            buildHeat(filtered);
        }

        document.querySelectorAll('input[data-footprint-cat]').forEach(input => {
            input.addEventListener('change', () => {
                const cat = input.getAttribute('data-footprint-cat');
                state.categories[cat] = input.checked;
                applyFilters();
            });
        });

        document.querySelectorAll('input[data-footprint-layer]').forEach(input => {
            input.addEventListener('change', () => {
                const layer = input.getAttribute('data-footprint-layer');
                state.layers[layer] = input.checked;
                applyFilters();
            });
        });

        applyFilters();

        const observer = new MutationObserver((mutations) => {
            mutations.forEach((m) => {
                if (m.attributeName === 'class') {
                    if (document.body.classList.contains('dark')) { map.removeLayer(lightTiles); if(!map.hasLayer(darkTiles)) darkTiles.addTo(map); }
                    else { map.removeLayer(darkTiles); if(!map.hasLayer(lightTiles)) lightTiles.addTo(map); }
                }
            });
        });
        observer.observe(document.body, { attributes: true });
        
        setTimeout(() => map.invalidateSize(), 500);
        window.addEventListener('resize', () => map.invalidateSize());
    }


    // --- HELPERS (Line, Text) ---
    function renderLine(history) {
        var dom = document.getElementById(IDS.LINE);
        if(!dom || !history) return;
        if(lineChart) lineChart.dispose();
        lineChart = echarts.init(dom);
        let isDark = document.body.classList.contains('dark');
        lineChart.setOption({
            tooltip: { trigger: 'axis', formatter: '{b}: {c} Citations' },
            grid: { top: 10, right: 10, bottom: 20, left: 30, containLabel: true },
            xAxis: { type: 'category', data: history.map(d => d.year), axisLine: { show: false }, axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } },
            yAxis: { type: 'value', splitLine: { show: false }, axisLabel: { color: isDark ? '#888' : '#666', fontSize: 9 } },
            series: [{ type: 'bar', data: history.map(d => d.citations), itemStyle: { color: isDark ? '#00e5ff' : '#1a0dab', borderRadius: [2,2,0,0] }, barWidth: '40%' }]
        });
    }

    function calculateAllMetrics(papers) {
        let n = papers.length;
        let adj = Array.from({length: n}, () => []);
        let degrees = new Array(n).fill(0);
        const getWeight = (i, j) => {
            let p1 = papers[i], p2 = papers[j];
            let w = 0;
            if(p1.venue === p2.venue && p1.venue) w += 1;
            let t1 = (p1.title||"").toLowerCase(); let t2 = (p2.title||"").toLowerCase();
            let common = t1.split(' ').filter(word => word.length > 4 && t2.includes(word)).length;
            if(common > 0) w += common * 0.5;
            return w;
        };
        for(let i=0; i<n; i++) {
            for(let j=i+1; j<n; j++) {
                let weight = getWeight(i, j);
                if(weight > 0.5) { adj[i].push(j); adj[j].push(i); degrees[i]++; degrees[j]++; }
            }
        }
        let eigenScores = new Array(n).fill(1.0);
        for(let iter=0; iter<10; iter++) {
            let nextScores = new Array(n).fill(0);
            for(let i=0; i<n; i++) { for(let neighbor of adj[i]) { nextScores[i] += eigenScores[neighbor]; } }
            let maxS = Math.max(...nextScores) || 1;
            eigenScores = nextScores.map(s => s / maxS);
        }
        let betweenness = new Array(n).fill(0);
        for(let s=0; s<n; s++) {
            let q = [s], preds = Array.from({length: n}, () => []), levels = new Array(n).fill(-1); levels[s] = 0;
            while(q.length > 0) {
                let v = q.shift();
                for(let w of adj[v]) {
                    if(levels[w] === -1) { levels[w] = levels[v] + 1; q.push(w); }
                    if(levels[w] === levels[v] + 1) { preds[w].push(v); }
                }
            }
            for(let i=0; i<n; i++) { if(i !== s && levels[i] > 0) { for(let p of preds[i]) betweenness[p] += 1; } }
        }
        const renderList = (id, scores, color) => {
            let ranked = papers.map((p, i) => ({ title: p.title, val: scores[i] })).sort((a,b) => b.val - a.val).slice(0, 3);
            let html = ranked.map((r, i) => `<div style="display:flex; gap:8px; margin-bottom:6px; align-items:start;"><div style="font-weight:bold; color:${color}; font-size:0.9em; min-width:15px;">${i+1}.</div><div style="font-size:0.8em; line-height:1.2; opacity:0.9;">${r.title}</div></div>`).join('');
            let el = document.getElementById(id); if(el) el.innerHTML = html;
        };
        renderList(IDS.LISTS.EIGEN, eigenScores, '#00ff41');
        renderList(IDS.LISTS.BETWEEN, betweenness, '#00e5ff');
        renderList(IDS.LISTS.DEGREE, degrees, '#e040fb');
    }

    function getColorByYear(year) {
        let y = parseInt(year) || 2022;
        if (y < 2020) return '#e040fb';
        if (y < 2023) return '#00e5ff';
        return '#00ff41';
    }

    function updateText(id, val) { var el = document.getElementById(id); if(el) el.innerText = val; }

    window.addEventListener('resize', function() {
        if(radarChart) radarChart.resize();
        if(lineChart) lineChart.resize();
        if(graphChart) graphChart.resize();
        if(collabChart) collabChart.resize();
        if(visitTrendChart) visitTrendChart.resize();
        if(visitDeviceChart) visitDeviceChart.resize();
    });

})();
</script>
